{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ruptures # ruptures is designed to perform offline change point algorithms within the Python language. Also in this library, new methods are presented. How to cite If you use ruptures in a scientific publication, we would appreciate citations to the following paper: Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods. Signal Processing , 167. [abstract] [doi] [pdf] Contact Concerning this package, its use and bugs, use the issue page of the ruptures repository . For other inquiries, you can contact me here .","title":"Welcome to ruptures"},{"location":"#welcome-to-ruptures","text":"ruptures is designed to perform offline change point algorithms within the Python language. Also in this library, new methods are presented. How to cite If you use ruptures in a scientific publication, we would appreciate citations to the following paper: Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods. Signal Processing , 167. [abstract] [doi] [pdf] Contact Concerning this package, its use and bugs, use the issue page of the ruptures repository . For other inquiries, you can contact me here .","title":"Welcome to ruptures"},{"location":"contributing/","text":"Contributing # Before contributing # In all following steps, it is highly recommended to use a virtual environment. Install the development version # It is important that you contribute to the latest version of the code. To that end, start by cloning the Github repository. git clone https://github.com/deepcharles/ruptures cd ruptures Then install the downloaded package. python -m pip install --verbose --no-build-isolation --editable . Install the requirements # Several packages are needed to format and test the code. They are listed in requirements-dev.txt and can be installed with the following command. With pip # pip install -r requirements-dev.txt With conda # conda --file requirements-dev.txt Then run the following command to install the pre-commit hooks. pre-commit install Pre-commit hooks # We use pre-commit to run Git hooks before submitting the code to review. These hook scripts perform simple tasks before each commit (code formatting mostly). Note that if you try to commit a non-compliant (i.e. badly formatted) file, pre-commit will modify this file and make the commit fail. However you need to stage the new changes yourself as pre-commit will not do that for you (this is by design; see here or here ). Fortunately, pre-commit outputs useful messages. The list of hooks (and their options) can be found in .pre-commit-config.yaml . For more information, see their website . If you want to manually run all pre-commit hooks on a repository, run pre-commit run --all-files . To run individual hooks use pre-commit run <hook_id> . Contribute to the code # Write tests # The following command executes the test suite. pytest Write docstrings # Contribute to the documentation # Use MkDocs . Use mkdocs serve to preview your changes. Once you are satisfied, no need to build the documentation, the CI will take care of that and publish it online at the next release of the package (if the pull request has been merged). Add examples to the gallery # An easy way to showcase your work with ruptures is to write a narrative example. To that, simply put a Jupyter notebook in the notebooks/ folder. To make it appear in the documentation, add a reference in mkdocs.yml ( nav > Gallery of examples ): if the notebook's name is my_notebook.ipynb , it will be available as notebooks/my_notebook.md . It will be rendered automatically when MkDocs builds the documentation. We welcome any interesting work about a new cost function, algorithm, data, calibration method, etc. Any other package can be used in combination with ruptures . However, each example should be clearly explained with text and figures. The amount of raw code should also remain limited for readability. Miscellaneous # Naming convention # We try to follow (roughly) a consistent naming convention of modules, classes, functions, etc. When in doubt, you can refer to the PEP 8 style guide for Python code .","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#before-contributing","text":"In all following steps, it is highly recommended to use a virtual environment.","title":"Before contributing"},{"location":"contributing/#install-the-development-version","text":"It is important that you contribute to the latest version of the code. To that end, start by cloning the Github repository. git clone https://github.com/deepcharles/ruptures cd ruptures Then install the downloaded package. python -m pip install --verbose --no-build-isolation --editable .","title":"Install the development version"},{"location":"contributing/#install-the-requirements","text":"Several packages are needed to format and test the code. They are listed in requirements-dev.txt and can be installed with the following command.","title":"Install the requirements"},{"location":"contributing/#with-pip","text":"pip install -r requirements-dev.txt","title":"With pip"},{"location":"contributing/#with-conda","text":"conda --file requirements-dev.txt Then run the following command to install the pre-commit hooks. pre-commit install","title":"With conda"},{"location":"contributing/#pre-commit-hooks","text":"We use pre-commit to run Git hooks before submitting the code to review. These hook scripts perform simple tasks before each commit (code formatting mostly). Note that if you try to commit a non-compliant (i.e. badly formatted) file, pre-commit will modify this file and make the commit fail. However you need to stage the new changes yourself as pre-commit will not do that for you (this is by design; see here or here ). Fortunately, pre-commit outputs useful messages. The list of hooks (and their options) can be found in .pre-commit-config.yaml . For more information, see their website . If you want to manually run all pre-commit hooks on a repository, run pre-commit run --all-files . To run individual hooks use pre-commit run <hook_id> .","title":"Pre-commit hooks"},{"location":"contributing/#contribute-to-the-code","text":"","title":"Contribute to the code"},{"location":"contributing/#write-tests","text":"The following command executes the test suite. pytest","title":"Write tests"},{"location":"contributing/#write-docstrings","text":"","title":"Write docstrings"},{"location":"contributing/#contribute-to-the-documentation","text":"Use MkDocs . Use mkdocs serve to preview your changes. Once you are satisfied, no need to build the documentation, the CI will take care of that and publish it online at the next release of the package (if the pull request has been merged).","title":"Contribute to the documentation"},{"location":"contributing/#add-examples-to-the-gallery","text":"An easy way to showcase your work with ruptures is to write a narrative example. To that, simply put a Jupyter notebook in the notebooks/ folder. To make it appear in the documentation, add a reference in mkdocs.yml ( nav > Gallery of examples ): if the notebook's name is my_notebook.ipynb , it will be available as notebooks/my_notebook.md . It will be rendered automatically when MkDocs builds the documentation. We welcome any interesting work about a new cost function, algorithm, data, calibration method, etc. Any other package can be used in combination with ruptures . However, each example should be clearly explained with text and figures. The amount of raw code should also remain limited for readability.","title":"Add examples to the gallery"},{"location":"contributing/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"contributing/#naming-convention","text":"We try to follow (roughly) a consistent naming convention of modules, classes, functions, etc. When in doubt, you can refer to the PEP 8 style guide for Python code .","title":"Naming convention"},{"location":"custom-cost-function/","text":"Creating a custom cost function # In order to define custom cost functions, simply create a class that inherits from ruptures.base.BaseCost and implement the methods .fit(signal) and .error(start, end) : The method .fit(signal) takes a signal as input and sets parameters. It returns 'self' . The method .error(start, end) takes two indexes 'start' and 'end' and returns the cost on the segment start:end. Example See this custom cost example .","title":"Custom cost function"},{"location":"custom-cost-function/#creating-a-custom-cost-function","text":"In order to define custom cost functions, simply create a class that inherits from ruptures.base.BaseCost and implement the methods .fit(signal) and .error(start, end) : The method .fit(signal) takes a signal as input and sets parameters. It returns 'self' . The method .error(start, end) takes two indexes 'start' and 'end' and returns the cost on the segment start:end. Example See this custom cost example .","title":"Creating a custom cost function"},{"location":"fit-and-predict/","text":"Fitting and prediction: estimator basics # ruptures has an object-oriented modelling approach (largely inspired by scikit-learn ): change point detection algorithms are broken down into two conceptual objects that inherits from base classes: BaseEstimator and BaseCost . Initializing a new estimator # Each change point detection algorithm inherits from the base class ruptures.base.BaseEstimator . When a class that inherits from the base estimator is created, the .__init__() method initializes an estimator with the following arguments: model : \"l1\", \"l2\", \"normal\", \"rbf\", \"linear\", etc. Cost function to use to compute the approximation error. cost : a custom cost function to the detection algorithm. Should be a BaseCost instance. jump : reduce the set of possible change point indexes; predicted change points can only be a multiple of jump . min_size : minimum number of samples between two change points. Making a prediction # The main methods are .fit() , .predict() , .fit_predict() : .fit() : generally takes a signal as input and fit the algorithm to the data. .predict() : performs the change point detection. This method returns a list of indexes corresponding to the end of each regimes. By design, the last element of this list is the number of samples. .fit_predict() : helper method which calls .fit() and .predict() successively.","title":"Fitting and predicting"},{"location":"fit-and-predict/#fitting-and-prediction-estimator-basics","text":"ruptures has an object-oriented modelling approach (largely inspired by scikit-learn ): change point detection algorithms are broken down into two conceptual objects that inherits from base classes: BaseEstimator and BaseCost .","title":"Fitting and prediction: estimator basics"},{"location":"fit-and-predict/#initializing-a-new-estimator","text":"Each change point detection algorithm inherits from the base class ruptures.base.BaseEstimator . When a class that inherits from the base estimator is created, the .__init__() method initializes an estimator with the following arguments: model : \"l1\", \"l2\", \"normal\", \"rbf\", \"linear\", etc. Cost function to use to compute the approximation error. cost : a custom cost function to the detection algorithm. Should be a BaseCost instance. jump : reduce the set of possible change point indexes; predicted change points can only be a multiple of jump . min_size : minimum number of samples between two change points.","title":"Initializing a new estimator"},{"location":"fit-and-predict/#making-a-prediction","text":"The main methods are .fit() , .predict() , .fit_predict() : .fit() : generally takes a signal as input and fit the algorithm to the data. .predict() : performs the change point detection. This method returns a list of indexes corresponding to the end of each regimes. By design, the last element of this list is the number of samples. .fit_predict() : helper method which calls .fit() and .predict() successively.","title":"Making a prediction"},{"location":"install/","text":"Installation # This library requires Python3 and the following packages: numpy , scipy and matplotlib (the last one is optional and only for display purposes). You can either install the latest stable release or the development version. Stable release # To install the latest stable release, use pip or conda . With pip python -m pip install ruptures With conda conda install ruptures Development release # Alternatively, you can install the development version of ruptures which can contain features that have not yet been integrated to the stable release. Two methods are available: with pip and manually. If you simply want the latest (and maybe untested) features, use pip . In order to contribute to the library (bug fix, new feature, code or documentation improvement), please install manually from the Github repository. With pip python -m pip install git+https://github.com/deepcharles/ruptures Manually Start by cloning the Github repository. git clone https://github.com/deepcharles/ruptures cd ruptures Then install the downloaded package. python -m pip install --verbose --no-build-isolation --editable . Upgrade # Show the current version of the package. python -m pip show ruptures In order to upgrade to the version, use the following command. python -m pip install -U ruptures","title":"Installation"},{"location":"install/#installation","text":"This library requires Python3 and the following packages: numpy , scipy and matplotlib (the last one is optional and only for display purposes). You can either install the latest stable release or the development version.","title":"Installation"},{"location":"install/#stable-release","text":"To install the latest stable release, use pip or conda . With pip python -m pip install ruptures With conda conda install ruptures","title":"Stable release"},{"location":"install/#development-release","text":"Alternatively, you can install the development version of ruptures which can contain features that have not yet been integrated to the stable release. Two methods are available: with pip and manually. If you simply want the latest (and maybe untested) features, use pip . In order to contribute to the library (bug fix, new feature, code or documentation improvement), please install manually from the Github repository. With pip python -m pip install git+https://github.com/deepcharles/ruptures Manually Start by cloning the Github repository. git clone https://github.com/deepcharles/ruptures cd ruptures Then install the downloaded package. python -m pip install --verbose --no-build-isolation --editable .","title":"Development release"},{"location":"install/#upgrade","text":"Show the current version of the package. python -m pip show ruptures In order to upgrade to the version, use the following command. python -m pip install -U ruptures","title":"Upgrade"},{"location":"license/","text":"License # This project is under BSD license. BSD 2-Clause License Copyright (c) 2017, ENS Paris-Saclay, CNRS All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license/#license","text":"This project is under BSD license. BSD 2-Clause License Copyright (c) 2017, ENS Paris-Saclay, CNRS All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"release-notes/","text":"Changelog # All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased # Added # add manual trigger to publish to Pypi PR#72 Changed # 1.0.6 - 2020-10-23 # Added # Fix legacy formatting errors PR#69 New documentation (from Sphinx to Mkdocs) PR#64 Separate requirements.txt and requirements-dev.txt PR#64 A changelog file ( link ) New Github actions for automatic generation of documentation Pre-commit code formatting using black Changed # Correction of display function test #64 Add badges in the README (Github repo) PR#62: pypi version, python version, code style, contributor list Typo in documentation ( PR#60 ) by @gjaeger Documentation theme Documentation site 1.0.5 - 2020-07-22 # Changed # Link to documentation in PyPi description","title":"Release notes"},{"location":"release-notes/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"release-notes/#unreleased","text":"","title":"Unreleased"},{"location":"release-notes/#added","text":"add manual trigger to publish to Pypi PR#72","title":"Added"},{"location":"release-notes/#changed","text":"","title":"Changed"},{"location":"release-notes/#106-2020-10-23","text":"","title":"1.0.6 - 2020-10-23"},{"location":"release-notes/#added_1","text":"Fix legacy formatting errors PR#69 New documentation (from Sphinx to Mkdocs) PR#64 Separate requirements.txt and requirements-dev.txt PR#64 A changelog file ( link ) New Github actions for automatic generation of documentation Pre-commit code formatting using black","title":"Added"},{"location":"release-notes/#changed_1","text":"Correction of display function test #64 Add badges in the README (Github repo) PR#62: pypi version, python version, code style, contributor list Typo in documentation ( PR#60 ) by @gjaeger Documentation theme Documentation site","title":"Changed"},{"location":"release-notes/#105-2020-07-22","text":"","title":"1.0.5 - 2020-07-22"},{"location":"release-notes/#changed_2","text":"Link to documentation in PyPi description","title":"Changed"},{"location":"what-is-cpd/","text":"What is change point detection? # Under construction. In the meantime, you can refer to the associated review of methods [Truong2020] . References # [Truong2020] Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods. Signal Processing , 167. [abstract] [doi] [pdf]","title":"Change point detection?"},{"location":"what-is-cpd/#what-is-change-point-detection","text":"Under construction. In the meantime, you can refer to the associated review of methods [Truong2020] .","title":"What is change point detection?"},{"location":"what-is-cpd/#references","text":"[Truong2020] Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods. Signal Processing , 167. [abstract] [doi] [pdf]","title":"References"},{"location":"code-reference/","text":"Introduction # This section describes the API of all functions and classes in the ruptures package. For a more intuitive description of each method, please refer to the User guide . Roughly, each module corresponds to a certain type of procedure: ruptures.base : base classes; ruptures.detection : search methods; ruptures.costs : costs functions; ruptures.datasets : data set generating utilities; ruptures.metrics : evaluation metrics; ruptures.show : display functions.","title":"Introduction"},{"location":"code-reference/#introduction","text":"This section describes the API of all functions and classes in the ruptures package. For a more intuitive description of each method, please refer to the User guide . Roughly, each module corresponds to a certain type of procedure: ruptures.base : base classes; ruptures.detection : search methods; ruptures.costs : costs functions; ruptures.datasets : data set generating utilities; ruptures.metrics : evaluation metrics; ruptures.show : display functions.","title":"Introduction"},{"location":"code-reference/base-reference/","text":"Base classes (ruptures.base) # # All estimators and cost functions are subclasses of [ BaseEstimator ][ruptures.base.BaseEstimator] and [ BaseCost ][ruptures.base.BaseCost] respectively. BaseCost # Base class for all segment cost classes. Notes All classes should specify all the parameters that can be set at the class level in their __init__ as explicit keyword arguments (no *args or **kwargs ). error ( self , start , end ) # Returns the cost on segment [start:end]. Source code in ruptures/base.py @abc . abstractmethod def error ( self , start , end ): \"\"\"Returns the cost on segment [start:end].\"\"\" pass fit ( self , * args , ** kwargs ) # Set the parameters of the cost function, for instance the Gram matrix, etc. Source code in ruptures/base.py @abc . abstractmethod def fit ( self , * args , ** kwargs ): \"\"\"Set the parameters of the cost function, for instance the Gram matrix, etc.\"\"\" pass sum_of_costs ( self , bkps ) # Returns the sum of segments cost for the given segmentation. Parameters: Name Type Description Default bkps list list of change points. By convention, bkps[-1]==n_samples. required Returns: Type Description float sum of costs Source code in ruptures/base.py def sum_of_costs ( self , bkps ): \"\"\"Returns the sum of segments cost for the given segmentation. Args: bkps (list): list of change points. By convention, bkps[-1]==n_samples. Returns: float: sum of costs \"\"\" soc = sum ( self . error ( start , end ) for start , end in pairwise ([ 0 ] + bkps )) return soc BaseEstimator # Base class for all change point detection estimators. Notes All estimators should specify all the parameters that can be set at the class level in their __init__ as explicit keyword arguments (no *args or **kwargs ). fit ( self , * args , ** kwargs ) # To call the segmentation algorithm. Source code in ruptures/base.py @abc . abstractmethod def fit ( self , * args , ** kwargs ): \"\"\"To call the segmentation algorithm.\"\"\" pass fit_predict ( self , * args , ** kwargs ) # To call the segmentation algorithm. Source code in ruptures/base.py @abc . abstractmethod def fit_predict ( self , * args , ** kwargs ): \"\"\"To call the segmentation algorithm.\"\"\" pass predict ( self , * args , ** kwargs ) # To call the segmentation algorithm. Source code in ruptures/base.py @abc . abstractmethod def predict ( self , * args , ** kwargs ): \"\"\"To call the segmentation algorithm.\"\"\" pass","title":"Base classes"},{"location":"code-reference/base-reference/#base-classes-rupturesbase","text":"","title":"Base classes (ruptures.base)"},{"location":"code-reference/base-reference/#ruptures.base","text":"All estimators and cost functions are subclasses of [ BaseEstimator ][ruptures.base.BaseEstimator] and [ BaseCost ][ruptures.base.BaseCost] respectively.","title":"ruptures.base"},{"location":"code-reference/base-reference/#ruptures.base.BaseCost","text":"Base class for all segment cost classes. Notes All classes should specify all the parameters that can be set at the class level in their __init__ as explicit keyword arguments (no *args or **kwargs ).","title":"BaseCost"},{"location":"code-reference/base-reference/#ruptures.base.BaseCost.error","text":"Returns the cost on segment [start:end]. Source code in ruptures/base.py @abc . abstractmethod def error ( self , start , end ): \"\"\"Returns the cost on segment [start:end].\"\"\" pass","title":"error()"},{"location":"code-reference/base-reference/#ruptures.base.BaseCost.fit","text":"Set the parameters of the cost function, for instance the Gram matrix, etc. Source code in ruptures/base.py @abc . abstractmethod def fit ( self , * args , ** kwargs ): \"\"\"Set the parameters of the cost function, for instance the Gram matrix, etc.\"\"\" pass","title":"fit()"},{"location":"code-reference/base-reference/#ruptures.base.BaseCost.sum_of_costs","text":"Returns the sum of segments cost for the given segmentation. Parameters: Name Type Description Default bkps list list of change points. By convention, bkps[-1]==n_samples. required Returns: Type Description float sum of costs Source code in ruptures/base.py def sum_of_costs ( self , bkps ): \"\"\"Returns the sum of segments cost for the given segmentation. Args: bkps (list): list of change points. By convention, bkps[-1]==n_samples. Returns: float: sum of costs \"\"\" soc = sum ( self . error ( start , end ) for start , end in pairwise ([ 0 ] + bkps )) return soc","title":"sum_of_costs()"},{"location":"code-reference/base-reference/#ruptures.base.BaseEstimator","text":"Base class for all change point detection estimators. Notes All estimators should specify all the parameters that can be set at the class level in their __init__ as explicit keyword arguments (no *args or **kwargs ).","title":"BaseEstimator"},{"location":"code-reference/base-reference/#ruptures.base.BaseEstimator.fit","text":"To call the segmentation algorithm. Source code in ruptures/base.py @abc . abstractmethod def fit ( self , * args , ** kwargs ): \"\"\"To call the segmentation algorithm.\"\"\" pass","title":"fit()"},{"location":"code-reference/base-reference/#ruptures.base.BaseEstimator.fit_predict","text":"To call the segmentation algorithm. Source code in ruptures/base.py @abc . abstractmethod def fit_predict ( self , * args , ** kwargs ): \"\"\"To call the segmentation algorithm.\"\"\" pass","title":"fit_predict()"},{"location":"code-reference/base-reference/#ruptures.base.BaseEstimator.predict","text":"To call the segmentation algorithm. Source code in ruptures/base.py @abc . abstractmethod def predict ( self , * args , ** kwargs ): \"\"\"To call the segmentation algorithm.\"\"\" pass","title":"predict()"},{"location":"code-reference/costs/costautoregressive-reference/","text":"Autoregressive model change (CostAutoregressive) # ruptures.costs.costautoregressive # CostAR # Least-squares estimate for changes in autoregressive coefficients. __init__ ( self , order = 4 ) special # Initialize the object. Parameters: Name Type Description Default order int autoregressive order 4 Source code in ruptures/costs/costautoregressive.py def __init__ ( self , order = 4 ): \"\"\"Initialize the object. Args: order (int): autoregressive order \"\"\" self . signal = None self . covar = None self . min_size = max ( 5 , order + 1 ) self . order = order error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than 'min_size' samples). Source code in ruptures/costs/costautoregressive.py def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost Raises: NotEnoughPoints: when the segment is too short (less than ``'min_size'`` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints y , X = self . signal [ start : end ], self . covar [ start : end ] _ , residual , _ , _ = lstsq ( X , y , rcond = None ) return residual . sum () fit ( self , signal ) # Set parameters of the instance. The signal must be 1D. Parameters: Name Type Description Default signal array 1d signal. Shape (n_samples, 1) or (n_samples,). required Returns: Type Description self the current object Source code in ruptures/costs/costautoregressive.py def fit ( self , signal ): \"\"\"Set parameters of the instance. The signal must be 1D. Args: signal (array): 1d signal. Shape (n_samples, 1) or (n_samples,). Returns: self: the current object \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal # lagged covariates n_samples , _ = self . signal . shape strides = ( self . signal . itemsize , self . signal . itemsize ) shape = ( n_samples - self . order , self . order ) lagged = as_strided ( self . signal , shape = shape , strides = strides ) # pad the first columns lagged_after_padding = np . pad ( lagged , (( self . order , 0 ), ( 0 , 0 )), mode = \"edge\" ) # add intercept self . covar = np . c_ [ lagged_after_padding , np . ones ( n_samples )] # pad signal on the edges self . signal [: self . order ] = self . signal [ self . order ] return self","title":"CostAR"},{"location":"code-reference/costs/costautoregressive-reference/#autoregressive-model-change-costautoregressive","text":"","title":"Autoregressive model change (CostAutoregressive)"},{"location":"code-reference/costs/costautoregressive-reference/#ruptures.costs.costautoregressive","text":"","title":"costautoregressive"},{"location":"code-reference/costs/costautoregressive-reference/#ruptures.costs.costautoregressive.CostAR","text":"Least-squares estimate for changes in autoregressive coefficients.","title":"CostAR"},{"location":"code-reference/costs/costautoregressive-reference/#ruptures.costs.costautoregressive.CostAR.__init__","text":"Initialize the object. Parameters: Name Type Description Default order int autoregressive order 4 Source code in ruptures/costs/costautoregressive.py def __init__ ( self , order = 4 ): \"\"\"Initialize the object. Args: order (int): autoregressive order \"\"\" self . signal = None self . covar = None self . min_size = max ( 5 , order + 1 ) self . order = order","title":"__init__()"},{"location":"code-reference/costs/costautoregressive-reference/#ruptures.costs.costautoregressive.CostAR.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than 'min_size' samples). Source code in ruptures/costs/costautoregressive.py def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost Raises: NotEnoughPoints: when the segment is too short (less than ``'min_size'`` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints y , X = self . signal [ start : end ], self . covar [ start : end ] _ , residual , _ , _ = lstsq ( X , y , rcond = None ) return residual . sum ()","title":"error()"},{"location":"code-reference/costs/costautoregressive-reference/#ruptures.costs.costautoregressive.CostAR.fit","text":"Set parameters of the instance. The signal must be 1D. Parameters: Name Type Description Default signal array 1d signal. Shape (n_samples, 1) or (n_samples,). required Returns: Type Description self the current object Source code in ruptures/costs/costautoregressive.py def fit ( self , signal ): \"\"\"Set parameters of the instance. The signal must be 1D. Args: signal (array): 1d signal. Shape (n_samples, 1) or (n_samples,). Returns: self: the current object \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal # lagged covariates n_samples , _ = self . signal . shape strides = ( self . signal . itemsize , self . signal . itemsize ) shape = ( n_samples - self . order , self . order ) lagged = as_strided ( self . signal , shape = shape , strides = strides ) # pad the first columns lagged_after_padding = np . pad ( lagged , (( self . order , 0 ), ( 0 , 0 )), mode = \"edge\" ) # add intercept self . covar = np . c_ [ lagged_after_padding , np . ones ( n_samples )] # pad signal on the edges self . signal [: self . order ] = self . signal [ self . order ] return self","title":"fit()"},{"location":"code-reference/costs/costl1-reference/","text":"CostL1 (least absolute deviation) # ruptures.costs.costl1.CostL1 # Least absolute deviation. __init__ ( self ) special # Initialize the object. Source code in ruptures/costs/costl1.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" self . signal = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costl1.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub = self . signal [ start : end ] med = np . median ( sub , axis = 0 ) return abs ( sub - med ) . sum () fit ( self , signal ) # Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostL1 self Source code in ruptures/costs/costl1.py def fit ( self , signal ) -> \"CostL1\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal return self","title":"CostL1"},{"location":"code-reference/costs/costl1-reference/#costl1-least-absolute-deviation","text":"","title":"CostL1 (least absolute deviation)"},{"location":"code-reference/costs/costl1-reference/#ruptures.costs.costl1.CostL1","text":"Least absolute deviation.","title":"CostL1"},{"location":"code-reference/costs/costl1-reference/#ruptures.costs.costl1.CostL1.__init__","text":"Initialize the object. Source code in ruptures/costs/costl1.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" self . signal = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costl1-reference/#ruptures.costs.costl1.CostL1.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costl1.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub = self . signal [ start : end ] med = np . median ( sub , axis = 0 ) return abs ( sub - med ) . sum ()","title":"error()"},{"location":"code-reference/costs/costl1-reference/#ruptures.costs.costl1.CostL1.fit","text":"Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostL1 self Source code in ruptures/costs/costl1.py def fit ( self , signal ) -> \"CostL1\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal return self","title":"fit()"},{"location":"code-reference/costs/costl2-reference/","text":"CostL2 (least squared deviation) # ruptures.costs.costl2.CostL2 # Least squared deviation. __init__ ( self ) special # Initialize the object. Source code in ruptures/costs/costl2.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . signal = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costl2.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints return self . signal [ start : end ] . var ( axis = 0 ) . sum () * ( end - start ) fit ( self , signal ) # Set parameters of the instance. Parameters: Name Type Description Default signal array array of shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostL2 self Source code in ruptures/costs/costl2.py def fit ( self , signal ) -> \"CostL2\" : \"\"\"Set parameters of the instance. Args: signal (array): array of shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal return self","title":"CostL2"},{"location":"code-reference/costs/costl2-reference/#costl2-least-squared-deviation","text":"","title":"CostL2 (least squared deviation)"},{"location":"code-reference/costs/costl2-reference/#ruptures.costs.costl2.CostL2","text":"Least squared deviation.","title":"CostL2"},{"location":"code-reference/costs/costl2-reference/#ruptures.costs.costl2.CostL2.__init__","text":"Initialize the object. Source code in ruptures/costs/costl2.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . signal = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costl2-reference/#ruptures.costs.costl2.CostL2.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costl2.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints return self . signal [ start : end ] . var ( axis = 0 ) . sum () * ( end - start )","title":"error()"},{"location":"code-reference/costs/costl2-reference/#ruptures.costs.costl2.CostL2.fit","text":"Set parameters of the instance. Parameters: Name Type Description Default signal array array of shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostL2 self Source code in ruptures/costs/costl2.py def fit ( self , signal ) -> \"CostL2\" : \"\"\"Set parameters of the instance. Args: signal (array): array of shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal return self","title":"fit()"},{"location":"code-reference/costs/costlinear-reference/","text":"Linear model change (CostLinear) # ruptures.costs.costlinear.CostLinear # Least-square estimate for linear changes. __init__ ( self ) special # Initialize the object. Source code in ruptures/costs/costlinear.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . signal = None self . covar = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costlinear.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints y , X = self . signal [ start : end ], self . covar [ start : end ] _ , residual , _ , _ = lstsq ( X , y , rcond = None ) return residual . sum () fit ( self , signal ) # Set parameters of the instance. The first column contains the observed variable. The other columns contains the covariates. Parameters: Name Type Description Default signal array signal of shape (n_samples, n_regressors+1) required Returns: Type Description CostLinear self Source code in ruptures/costs/costlinear.py def fit ( self , signal ) -> \"CostLinear\" : \"\"\"Set parameters of the instance. The first column contains the observed variable. The other columns contains the covariates. Args: signal (array): signal of shape (n_samples, n_regressors+1) Returns: self \"\"\" assert signal . ndim > 1 , \"Not enough dimensions\" self . signal = signal [:, 0 ] . reshape ( - 1 , 1 ) self . covar = signal [:, 1 :] return self","title":"CostLinear"},{"location":"code-reference/costs/costlinear-reference/#linear-model-change-costlinear","text":"","title":"Linear model change (CostLinear)"},{"location":"code-reference/costs/costlinear-reference/#ruptures.costs.costlinear.CostLinear","text":"Least-square estimate for linear changes.","title":"CostLinear"},{"location":"code-reference/costs/costlinear-reference/#ruptures.costs.costlinear.CostLinear.__init__","text":"Initialize the object. Source code in ruptures/costs/costlinear.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . signal = None self . covar = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costlinear-reference/#ruptures.costs.costlinear.CostLinear.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costlinear.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints y , X = self . signal [ start : end ], self . covar [ start : end ] _ , residual , _ , _ = lstsq ( X , y , rcond = None ) return residual . sum ()","title":"error()"},{"location":"code-reference/costs/costlinear-reference/#ruptures.costs.costlinear.CostLinear.fit","text":"Set parameters of the instance. The first column contains the observed variable. The other columns contains the covariates. Parameters: Name Type Description Default signal array signal of shape (n_samples, n_regressors+1) required Returns: Type Description CostLinear self Source code in ruptures/costs/costlinear.py def fit ( self , signal ) -> \"CostLinear\" : \"\"\"Set parameters of the instance. The first column contains the observed variable. The other columns contains the covariates. Args: signal (array): signal of shape (n_samples, n_regressors+1) Returns: self \"\"\" assert signal . ndim > 1 , \"Not enough dimensions\" self . signal = signal [:, 0 ] . reshape ( - 1 , 1 ) self . covar = signal [:, 1 :] return self","title":"fit()"},{"location":"code-reference/costs/costml-reference/","text":"Mahalanobis-type change (CostMl) # ruptures.costs.costml.CostMl # Mahalanobis-type cost function. __init__ ( self , metric = None ) special # Create a new instance. Parameters: Name Type Description Default metric ndarray PSD matrix that defines a Mahalanobis-type pseudo distance. If None, defaults to the Mahalanobis matrix. Shape (n_features, n_features). None Source code in ruptures/costs/costml.py def __init__ ( self , metric = None ): \"\"\"Create a new instance. Args: metric (ndarray, optional): PSD matrix that defines a Mahalanobis-type pseudo distance. If None, defaults to the Mahalanobis matrix. Shape (n_features, n_features). \"\"\" self . metric = metric self . gram = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than 'min_size' samples). Source code in ruptures/costs/costml.py def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost Raises: NotEnoughPoints: when the segment is too short (less than ``'min_size'`` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub_gram = self . gram [ start : end , start : end ] val = np . diagonal ( sub_gram ) . sum () val -= sub_gram . sum () / ( end - start ) return val fit ( self , signal ) # Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostMl self Source code in ruptures/costs/costml.py def fit ( self , signal ) -> \"CostMl\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" s_ = signal . reshape ( - 1 , 1 ) if signal . ndim == 1 else signal # Mahalanobis metric if self.metric is None if self . metric is None : covar = np . cov ( s_ . T ) self . metric = inv ( covar . reshape ( 1 , 1 ) if covar . size == 1 else covar ) self . gram = s_ . dot ( self . metric ) . dot ( s_ . T ) return self","title":"CostMl"},{"location":"code-reference/costs/costml-reference/#mahalanobis-type-change-costml","text":"","title":"Mahalanobis-type change (CostMl)"},{"location":"code-reference/costs/costml-reference/#ruptures.costs.costml.CostMl","text":"Mahalanobis-type cost function.","title":"CostMl"},{"location":"code-reference/costs/costml-reference/#ruptures.costs.costml.CostMl.__init__","text":"Create a new instance. Parameters: Name Type Description Default metric ndarray PSD matrix that defines a Mahalanobis-type pseudo distance. If None, defaults to the Mahalanobis matrix. Shape (n_features, n_features). None Source code in ruptures/costs/costml.py def __init__ ( self , metric = None ): \"\"\"Create a new instance. Args: metric (ndarray, optional): PSD matrix that defines a Mahalanobis-type pseudo distance. If None, defaults to the Mahalanobis matrix. Shape (n_features, n_features). \"\"\" self . metric = metric self . gram = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costml-reference/#ruptures.costs.costml.CostMl.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than 'min_size' samples). Source code in ruptures/costs/costml.py def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost Raises: NotEnoughPoints: when the segment is too short (less than ``'min_size'`` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub_gram = self . gram [ start : end , start : end ] val = np . diagonal ( sub_gram ) . sum () val -= sub_gram . sum () / ( end - start ) return val","title":"error()"},{"location":"code-reference/costs/costml-reference/#ruptures.costs.costml.CostMl.fit","text":"Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostMl self Source code in ruptures/costs/costml.py def fit ( self , signal ) -> \"CostMl\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" s_ = signal . reshape ( - 1 , 1 ) if signal . ndim == 1 else signal # Mahalanobis metric if self.metric is None if self . metric is None : covar = np . cov ( s_ . T ) self . metric = inv ( covar . reshape ( 1 , 1 ) if covar . size == 1 else covar ) self . gram = s_ . dot ( self . metric ) . dot ( s_ . T ) return self","title":"fit()"},{"location":"code-reference/costs/costnormal-reference/","text":"Gaussian process change (CostNormal) # ruptures.costs.costnormal.CostNormal # Gaussian process change. __init__ ( self ) special # Initialize the object. Source code in ruptures/costs/costnormal.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . signal = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costnormal.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub = self . signal [ start : end ] if self . signal . shape [ 1 ] > 1 : cov = np . cov ( sub . T ) else : cov = np . array ([[ sub . var ()]]) _ , val = slogdet ( cov ) return val * ( end - start ) fit ( self , signal ) # Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostNormal self Source code in ruptures/costs/costnormal.py def fit ( self , signal ) -> \"CostNormal\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal return self","title":"CostNormal"},{"location":"code-reference/costs/costnormal-reference/#gaussian-process-change-costnormal","text":"","title":"Gaussian process change (CostNormal)"},{"location":"code-reference/costs/costnormal-reference/#ruptures.costs.costnormal.CostNormal","text":"Gaussian process change.","title":"CostNormal"},{"location":"code-reference/costs/costnormal-reference/#ruptures.costs.costnormal.CostNormal.__init__","text":"Initialize the object. Source code in ruptures/costs/costnormal.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . signal = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costnormal-reference/#ruptures.costs.costnormal.CostNormal.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costnormal.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub = self . signal [ start : end ] if self . signal . shape [ 1 ] > 1 : cov = np . cov ( sub . T ) else : cov = np . array ([[ sub . var ()]]) _ , val = slogdet ( cov ) return val * ( end - start )","title":"error()"},{"location":"code-reference/costs/costnormal-reference/#ruptures.costs.costnormal.CostNormal.fit","text":"Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostNormal self Source code in ruptures/costs/costnormal.py def fit ( self , signal ) -> \"CostNormal\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal return self","title":"fit()"},{"location":"code-reference/costs/costrank-reference/","text":"Rank-based change (CostRank) # ruptures.costs.costrank.CostRank # Rank-based cost function __init__ ( self ) special # Initialize the object. Source code in ruptures/costs/costrank.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . inv_cov = None self . ranks = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costrank.py def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints mean = np . reshape ( np . mean ( self . ranks [ start : end ], axis = 0 ), ( - 1 , 1 )) return - ( end - start ) * mean . T @ self . inv_cov @ mean fit ( self , signal ) # Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostRank self Source code in ruptures/costs/costrank.py def fit ( self , signal ) -> \"CostRank\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : signal = signal . reshape ( - 1 , 1 ) obs , vars = signal . shape # Convert signal data into ranks in the range [1, n] ranks = rankdata ( signal , axis = 0 ) # Center the ranks into the range [-(n+1)/2, (n+1)/2] centered_ranks = ranks - (( obs + 1 ) / 2 ) # Sigma is the covariance of these ranks. # If it's a scalar, reshape it into a 1x1 matrix cov = np . cov ( centered_ranks , rowvar = False , bias = True ) . reshape ( vars , vars ) # Use the pseudoinverse to handle linear dependencies # see Lung-Yut-Fong, A., L\u00e9vy-Leduc, C., & Capp\u00e9, O. (2015) try : self . inv_cov = pinv ( cov ) except LinAlgError as e : raise LinAlgError ( \"The covariance matrix of the rank signal is not invertible and the \" \"pseudo-inverse computation did not converge.\" ) from e self . ranks = centered_ranks return self","title":"CostRank"},{"location":"code-reference/costs/costrank-reference/#rank-based-change-costrank","text":"","title":"Rank-based change (CostRank)"},{"location":"code-reference/costs/costrank-reference/#ruptures.costs.costrank.CostRank","text":"Rank-based cost function","title":"CostRank"},{"location":"code-reference/costs/costrank-reference/#ruptures.costs.costrank.CostRank.__init__","text":"Initialize the object. Source code in ruptures/costs/costrank.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . inv_cov = None self . ranks = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costrank-reference/#ruptures.costs.costrank.CostRank.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costrank.py def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints mean = np . reshape ( np . mean ( self . ranks [ start : end ], axis = 0 ), ( - 1 , 1 )) return - ( end - start ) * mean . T @ self . inv_cov @ mean","title":"error()"},{"location":"code-reference/costs/costrank-reference/#ruptures.costs.costrank.CostRank.fit","text":"Set parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostRank self Source code in ruptures/costs/costrank.py def fit ( self , signal ) -> \"CostRank\" : \"\"\"Set parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : signal = signal . reshape ( - 1 , 1 ) obs , vars = signal . shape # Convert signal data into ranks in the range [1, n] ranks = rankdata ( signal , axis = 0 ) # Center the ranks into the range [-(n+1)/2, (n+1)/2] centered_ranks = ranks - (( obs + 1 ) / 2 ) # Sigma is the covariance of these ranks. # If it's a scalar, reshape it into a 1x1 matrix cov = np . cov ( centered_ranks , rowvar = False , bias = True ) . reshape ( vars , vars ) # Use the pseudoinverse to handle linear dependencies # see Lung-Yut-Fong, A., L\u00e9vy-Leduc, C., & Capp\u00e9, O. (2015) try : self . inv_cov = pinv ( cov ) except LinAlgError as e : raise LinAlgError ( \"The covariance matrix of the rank signal is not invertible and the \" \"pseudo-inverse computation did not converge.\" ) from e self . ranks = centered_ranks return self","title":"fit()"},{"location":"code-reference/costs/costrbf-reference/","text":"Kernelized mean change (CostRbf) # ruptures.costs.costrbf.CostRbf # Kernel cost function (rbf kernel). __init__ ( self ) special # Initialize the object. Source code in ruptures/costs/costrbf.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . gram = None self . min_size = 2 error ( self , start , end ) # Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costrbf.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub_gram = self . gram [ start : end , start : end ] val = np . diagonal ( sub_gram ) . sum () val -= sub_gram . sum () / ( end - start ) return val fit ( self , signal ) # Sets parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostRbf self Source code in ruptures/costs/costrbf.py def fit ( self , signal ) -> \"CostRbf\" : \"\"\"Sets parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : K = pdist ( signal . reshape ( - 1 , 1 ), metric = \"sqeuclidean\" ) else : K = pdist ( signal , metric = \"sqeuclidean\" ) K_median = np . median ( K ) if K_median != 0 : K /= K_median np . clip ( K , 1e-2 , 1e2 , K ) self . gram = np . exp ( squareform ( - K )) return self","title":"CostRbf"},{"location":"code-reference/costs/costrbf-reference/#kernelized-mean-change-costrbf","text":"","title":"Kernelized mean change (CostRbf)"},{"location":"code-reference/costs/costrbf-reference/#ruptures.costs.costrbf.CostRbf","text":"Kernel cost function (rbf kernel).","title":"CostRbf"},{"location":"code-reference/costs/costrbf-reference/#ruptures.costs.costrbf.CostRbf.__init__","text":"Initialize the object. Source code in ruptures/costs/costrbf.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" self . gram = None self . min_size = 2","title":"__init__()"},{"location":"code-reference/costs/costrbf-reference/#ruptures.costs.costrbf.CostRbf.error","text":"Return the approximation cost on the segment [start:end]. Parameters: Name Type Description Default start int start of the segment required end int end of the segment required Returns: Type Description float segment cost Exceptions: Type Description NotEnoughPoints when the segment is too short (less than min_size samples). Source code in ruptures/costs/costrbf.py def error ( self , start , end ) -> float : \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: segment cost Raises: NotEnoughPoints: when the segment is too short (less than `min_size` samples). \"\"\" if end - start < self . min_size : raise NotEnoughPoints sub_gram = self . gram [ start : end , start : end ] val = np . diagonal ( sub_gram ) . sum () val -= sub_gram . sum () / ( end - start ) return val","title":"error()"},{"location":"code-reference/costs/costrbf-reference/#ruptures.costs.costrbf.CostRbf.fit","text":"Sets parameters of the instance. Parameters: Name Type Description Default signal array signal. Shape (n_samples,) or (n_samples, n_features) required Returns: Type Description CostRbf self Source code in ruptures/costs/costrbf.py def fit ( self , signal ) -> \"CostRbf\" : \"\"\"Sets parameters of the instance. Args: signal (array): signal. Shape (n_samples,) or (n_samples, n_features) Returns: self \"\"\" if signal . ndim == 1 : K = pdist ( signal . reshape ( - 1 , 1 ), metric = \"sqeuclidean\" ) else : K = pdist ( signal , metric = \"sqeuclidean\" ) K_median = np . median ( K ) if K_median != 0 : K /= K_median np . clip ( K , 1e-2 , 1e2 , K ) self . gram = np . exp ( squareform ( - K )) return self","title":"fit()"},{"location":"code-reference/datasets/pw_constant-reference/","text":"Piecewise constant (pw_constant) # ruptures.datasets.pw_constant.pw_constant ( n_samples = 200 , n_features = 1 , n_bkps = 3 , noise_std = None , delta = ( 1 , 10 )) # Return a piecewise constant signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_features int number of dimensions 1 n_bkps int number of changepoints 3 noise_std float noise std. If None, no noise is added None delta tuple (delta_min, delta_max) max and min jump values (1, 10) Returns: Type Description tuple signal of shape (n_samples, n_features), list of breakpoints Source code in ruptures/datasets/pw_constant.py def pw_constant ( n_samples = 200 , n_features = 1 , n_bkps = 3 , noise_std = None , delta = ( 1 , 10 )): \"\"\"Return a piecewise constant signal and the associated changepoints. Args: n_samples (int): signal length n_features (int, optional): number of dimensions n_bkps (int, optional): number of changepoints noise_std (float, optional): noise std. If None, no noise is added delta (tuple, optional): (delta_min, delta_max) max and min jump values Returns: tuple: signal of shape (n_samples, n_features), list of breakpoints \"\"\" # breakpoints bkps = draw_bkps ( n_samples , n_bkps ) # we create the signal signal = np . empty (( n_samples , n_features ), dtype = float ) tt_ = np . arange ( n_samples ) delta_min , delta_max = delta # mean value center = np . zeros ( n_features ) for ind in np . split ( tt_ , bkps ): if ind . size > 0 : # jump value jump = rd . uniform ( delta_min , delta_max , size = n_features ) spin = rd . choice ([ - 1 , 1 ], n_features ) center += jump * spin signal [ ind ] = center if noise_std is not None : noise = rd . normal ( size = signal . shape ) * noise_std signal = signal + noise return signal , bkps","title":"Piecewise constant"},{"location":"code-reference/datasets/pw_constant-reference/#piecewise-constant-pw_constant","text":"","title":"Piecewise constant (pw_constant)"},{"location":"code-reference/datasets/pw_constant-reference/#ruptures.datasets.pw_constant.pw_constant","text":"Return a piecewise constant signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_features int number of dimensions 1 n_bkps int number of changepoints 3 noise_std float noise std. If None, no noise is added None delta tuple (delta_min, delta_max) max and min jump values (1, 10) Returns: Type Description tuple signal of shape (n_samples, n_features), list of breakpoints Source code in ruptures/datasets/pw_constant.py def pw_constant ( n_samples = 200 , n_features = 1 , n_bkps = 3 , noise_std = None , delta = ( 1 , 10 )): \"\"\"Return a piecewise constant signal and the associated changepoints. Args: n_samples (int): signal length n_features (int, optional): number of dimensions n_bkps (int, optional): number of changepoints noise_std (float, optional): noise std. If None, no noise is added delta (tuple, optional): (delta_min, delta_max) max and min jump values Returns: tuple: signal of shape (n_samples, n_features), list of breakpoints \"\"\" # breakpoints bkps = draw_bkps ( n_samples , n_bkps ) # we create the signal signal = np . empty (( n_samples , n_features ), dtype = float ) tt_ = np . arange ( n_samples ) delta_min , delta_max = delta # mean value center = np . zeros ( n_features ) for ind in np . split ( tt_ , bkps ): if ind . size > 0 : # jump value jump = rd . uniform ( delta_min , delta_max , size = n_features ) spin = rd . choice ([ - 1 , 1 ], n_features ) center += jump * spin signal [ ind ] = center if noise_std is not None : noise = rd . normal ( size = signal . shape ) * noise_std signal = signal + noise return signal , bkps","title":"pw_constant()"},{"location":"code-reference/datasets/pw_linear-reference/","text":"Piecewise linear (pw_linear) # ruptures.datasets.pw_linear.pw_linear ( n_samples = 200 , n_features = 1 , n_bkps = 3 , noise_std = None ) # Return piecewise linear signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_features int number of covariates 1 n_bkps int number of change points 3 noise_std float noise std. If None, no noise is added None Returns: Type Description tuple signal of shape (n_samples, n_features+1), list of breakpoints Source code in ruptures/datasets/pw_linear.py def pw_linear ( n_samples = 200 , n_features = 1 , n_bkps = 3 , noise_std = None ): \"\"\"Return piecewise linear signal and the associated changepoints. Args: n_samples (int, optional): signal length n_features (int, optional): number of covariates n_bkps (int, optional): number of change points noise_std (float, optional): noise std. If None, no noise is added Returns: tuple: signal of shape (n_samples, n_features+1), list of breakpoints \"\"\" covar = normal ( size = ( n_samples , n_features )) linear_coeff , bkps = pw_constant ( n_samples = n_samples , n_bkps = n_bkps , n_features = n_features , noise_std = None ) var = np . sum ( linear_coeff * covar , axis = 1 ) if noise_std is not None : var += normal ( scale = noise_std , size = var . shape ) signal = np . c_ [ var , covar ] return signal , bkps","title":"Piecewise linear"},{"location":"code-reference/datasets/pw_linear-reference/#piecewise-linear-pw_linear","text":"","title":"Piecewise linear (pw_linear)"},{"location":"code-reference/datasets/pw_linear-reference/#ruptures.datasets.pw_linear.pw_linear","text":"Return piecewise linear signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_features int number of covariates 1 n_bkps int number of change points 3 noise_std float noise std. If None, no noise is added None Returns: Type Description tuple signal of shape (n_samples, n_features+1), list of breakpoints Source code in ruptures/datasets/pw_linear.py def pw_linear ( n_samples = 200 , n_features = 1 , n_bkps = 3 , noise_std = None ): \"\"\"Return piecewise linear signal and the associated changepoints. Args: n_samples (int, optional): signal length n_features (int, optional): number of covariates n_bkps (int, optional): number of change points noise_std (float, optional): noise std. If None, no noise is added Returns: tuple: signal of shape (n_samples, n_features+1), list of breakpoints \"\"\" covar = normal ( size = ( n_samples , n_features )) linear_coeff , bkps = pw_constant ( n_samples = n_samples , n_bkps = n_bkps , n_features = n_features , noise_std = None ) var = np . sum ( linear_coeff * covar , axis = 1 ) if noise_std is not None : var += normal ( scale = noise_std , size = var . shape ) signal = np . c_ [ var , covar ] return signal , bkps","title":"pw_linear()"},{"location":"code-reference/datasets/pw_normal-reference/","text":"Piecewise Gaussian (pw_normal) # ruptures.datasets.pw_normal.pw_normal ( n_samples = 200 , n_bkps = 3 ) # Return a 2D piecewise Gaussian signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_bkps int number of change points 3 Returns: Type Description tuple signal of shape (n_samples, 2), list of breakpoints Source code in ruptures/datasets/pw_normal.py def pw_normal ( n_samples = 200 , n_bkps = 3 ): \"\"\"Return a 2D piecewise Gaussian signal and the associated changepoints. Args: n_samples (int, optional): signal length n_bkps (int, optional): number of change points Returns: tuple: signal of shape (n_samples, 2), list of breakpoints \"\"\" # breakpoints bkps = draw_bkps ( n_samples , n_bkps ) # we create the signal signal = np . zeros (( n_samples , 2 ), dtype = float ) cov1 = np . array ([[ 1 , 0.9 ], [ 0.9 , 1 ]]) cov2 = np . array ([[ 1 , - 0.9 ], [ - 0.9 , 1 ]]) for sub , cov in zip ( np . split ( signal , bkps ), cycle (( cov1 , cov2 ))): n_sub , _ = sub . shape sub += rd . multivariate_normal ([ 0 , 0 ], cov , size = n_sub ) return signal , bkps","title":"Piecewise normal"},{"location":"code-reference/datasets/pw_normal-reference/#piecewise-gaussian-pw_normal","text":"","title":"Piecewise Gaussian (pw_normal)"},{"location":"code-reference/datasets/pw_normal-reference/#ruptures.datasets.pw_normal.pw_normal","text":"Return a 2D piecewise Gaussian signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_bkps int number of change points 3 Returns: Type Description tuple signal of shape (n_samples, 2), list of breakpoints Source code in ruptures/datasets/pw_normal.py def pw_normal ( n_samples = 200 , n_bkps = 3 ): \"\"\"Return a 2D piecewise Gaussian signal and the associated changepoints. Args: n_samples (int, optional): signal length n_bkps (int, optional): number of change points Returns: tuple: signal of shape (n_samples, 2), list of breakpoints \"\"\" # breakpoints bkps = draw_bkps ( n_samples , n_bkps ) # we create the signal signal = np . zeros (( n_samples , 2 ), dtype = float ) cov1 = np . array ([[ 1 , 0.9 ], [ 0.9 , 1 ]]) cov2 = np . array ([[ 1 , - 0.9 ], [ - 0.9 , 1 ]]) for sub , cov in zip ( np . split ( signal , bkps ), cycle (( cov1 , cov2 ))): n_sub , _ = sub . shape sub += rd . multivariate_normal ([ 0 , 0 ], cov , size = n_sub ) return signal , bkps","title":"pw_normal()"},{"location":"code-reference/datasets/pw_wavy-reference/","text":"Piecewise wavy (pw_wavy) # ruptures.datasets.pw_wavy.pw_wavy ( n_samples = 200 , n_bkps = 3 , noise_std = None ) # Return a 1D piecewise wavy signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_bkps int number of changepoints 3 noise_std float noise std. If None, no noise is added None Returns: Type Description tuple signal of shape (n_samples, 1), list of breakpoints Source code in ruptures/datasets/pw_wavy.py def pw_wavy ( n_samples = 200 , n_bkps = 3 , noise_std = None ): \"\"\"Return a 1D piecewise wavy signal and the associated changepoints. Args: n_samples (int, optional): signal length n_bkps (int, optional): number of changepoints noise_std (float, optional): noise std. If None, no noise is added Returns: tuple: signal of shape (n_samples, 1), list of breakpoints \"\"\" # breakpoints bkps = draw_bkps ( n_samples , n_bkps ) # we create the signal f1 = np . array ([ 0.075 , 0.1 ]) f2 = np . array ([ 0.1 , 0.125 ]) freqs = np . zeros (( n_samples , 2 )) for sub , val in zip ( np . split ( freqs , bkps [: - 1 ]), cycle ([ f1 , f2 ])): sub += val tt = np . arange ( n_samples ) # DeprecationWarning: Calling np.sum(generator) is deprecated # Use np.sum(np.from_iter(generator)) or the python sum builtin instead. signal = np . sum ([ np . sin ( 2 * np . pi * tt * f ) for f in freqs . T ], axis = 0 ) if noise_std is not None : noise = normal ( scale = noise_std , size = signal . shape ) signal += noise return signal , bkps","title":"Piecewise wavy"},{"location":"code-reference/datasets/pw_wavy-reference/#piecewise-wavy-pw_wavy","text":"","title":"Piecewise wavy (pw_wavy)"},{"location":"code-reference/datasets/pw_wavy-reference/#ruptures.datasets.pw_wavy.pw_wavy","text":"Return a 1D piecewise wavy signal and the associated changepoints. Parameters: Name Type Description Default n_samples int signal length 200 n_bkps int number of changepoints 3 noise_std float noise std. If None, no noise is added None Returns: Type Description tuple signal of shape (n_samples, 1), list of breakpoints Source code in ruptures/datasets/pw_wavy.py def pw_wavy ( n_samples = 200 , n_bkps = 3 , noise_std = None ): \"\"\"Return a 1D piecewise wavy signal and the associated changepoints. Args: n_samples (int, optional): signal length n_bkps (int, optional): number of changepoints noise_std (float, optional): noise std. If None, no noise is added Returns: tuple: signal of shape (n_samples, 1), list of breakpoints \"\"\" # breakpoints bkps = draw_bkps ( n_samples , n_bkps ) # we create the signal f1 = np . array ([ 0.075 , 0.1 ]) f2 = np . array ([ 0.1 , 0.125 ]) freqs = np . zeros (( n_samples , 2 )) for sub , val in zip ( np . split ( freqs , bkps [: - 1 ]), cycle ([ f1 , f2 ])): sub += val tt = np . arange ( n_samples ) # DeprecationWarning: Calling np.sum(generator) is deprecated # Use np.sum(np.from_iter(generator)) or the python sum builtin instead. signal = np . sum ([ np . sin ( 2 * np . pi * tt * f ) for f in freqs . T ], axis = 0 ) if noise_std is not None : noise = normal ( scale = noise_std , size = signal . shape ) signal += noise return signal , bkps","title":"pw_wavy()"},{"location":"code-reference/detection/binseg-reference/","text":"Binary segmentation # ruptures.detection.binseg.Binseg # Binary segmentation. __init__ ( self , model = 'l2' , custom_cost = None , min_size = 2 , jump = 5 , params = None ) special # Initialize a Binseg instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\",...]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. Defaults to 2 samples. 2 jump int subsample (one every jump points). Defaults to 5 samples. 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/binseg.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Initialize a Binseg instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\",...]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. Defaults to 2 samples. jump (int, optional): subsample (one every *jump* points). Defaults to 5 samples. params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None self . signal = None # cache for intermediate results self . single_bkp = lru_cache ( maxsize = None )( self . _single_bkp ) fit ( self , signal ) # Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Binseg self Source code in ruptures/detection/binseg.py def fit ( self , signal ) -> \"Binseg\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal self . n_samples , _ = self . signal . shape self . cost . fit ( signal ) self . single_bkp . cache_clear () return self fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ) # Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required n_bkps int number of breakpoints. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/binseg.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). n_bkps (int): number of breakpoints. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.binseg.Binseg.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/binseg.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.binseg.Binseg.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg partition = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"Binseg"},{"location":"code-reference/detection/binseg-reference/#binary-segmentation","text":"","title":"Binary segmentation"},{"location":"code-reference/detection/binseg-reference/#ruptures.detection.binseg.Binseg","text":"Binary segmentation.","title":"Binseg"},{"location":"code-reference/detection/binseg-reference/#ruptures.detection.binseg.Binseg.__init__","text":"Initialize a Binseg instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\",...]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. Defaults to 2 samples. 2 jump int subsample (one every jump points). Defaults to 5 samples. 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/binseg.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Initialize a Binseg instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\",...]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. Defaults to 2 samples. jump (int, optional): subsample (one every *jump* points). Defaults to 5 samples. params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None self . signal = None # cache for intermediate results self . single_bkp = lru_cache ( maxsize = None )( self . _single_bkp )","title":"__init__()"},{"location":"code-reference/detection/binseg-reference/#ruptures.detection.binseg.Binseg.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Binseg self Source code in ruptures/detection/binseg.py def fit ( self , signal ) -> \"Binseg\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal self . n_samples , _ = self . signal . shape self . cost . fit ( signal ) self . single_bkp . cache_clear () return self","title":"fit()"},{"location":"code-reference/detection/binseg-reference/#ruptures.detection.binseg.Binseg.fit_predict","text":"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required n_bkps int number of breakpoints. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/binseg.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). n_bkps (int): number of breakpoints. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/binseg-reference/#ruptures.detection.binseg.Binseg.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.binseg.Binseg.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/binseg.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.binseg.Binseg.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg partition = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"predict()"},{"location":"code-reference/detection/bottomup-reference/","text":"Bottom-up segmentation # ruptures.detection.bottomup.BottomUp # Bottom-up segmentation. __init__ ( self , model = 'l2' , custom_cost = None , min_size = 2 , jump = 5 , params = None ) special # Initialize a BottomUp instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. Defaults to 2 samples. 2 jump int subsample (one every jump points). Defaults to 5 samples. 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/bottomup.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Initialize a BottomUp instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. Defaults to 2 samples. jump (int, optional): subsample (one every *jump* points). Defaults to 5 samples. params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None self . signal = None self . leaves = None self . merge = lru_cache ( maxsize = None )( self . _merge ) fit ( self , signal ) # Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description BottomUp self Source code in ruptures/detection/bottomup.py def fit ( self , signal ) -> \"BottomUp\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params self . cost . fit ( signal ) self . merge . cache_clear () if signal . ndim == 1 : ( n_samples ,) = signal . shape else : n_samples , _ = signal . shape self . n_samples = n_samples self . leaves = self . _grow_tree () return self fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ) # Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required n_bkps int number of breakpoints. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/bottomup.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). n_bkps (int): number of breakpoints. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.bottomup.BottomUp.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/bottomup.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.bottomup.BottomUp.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg partition = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"BottomUp"},{"location":"code-reference/detection/bottomup-reference/#bottom-up-segmentation","text":"","title":"Bottom-up segmentation"},{"location":"code-reference/detection/bottomup-reference/#ruptures.detection.bottomup.BottomUp","text":"Bottom-up segmentation.","title":"BottomUp"},{"location":"code-reference/detection/bottomup-reference/#ruptures.detection.bottomup.BottomUp.__init__","text":"Initialize a BottomUp instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. Defaults to 2 samples. 2 jump int subsample (one every jump points). Defaults to 5 samples. 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/bottomup.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Initialize a BottomUp instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. Defaults to 2 samples. jump (int, optional): subsample (one every *jump* points). Defaults to 5 samples. params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None self . signal = None self . leaves = None self . merge = lru_cache ( maxsize = None )( self . _merge )","title":"__init__()"},{"location":"code-reference/detection/bottomup-reference/#ruptures.detection.bottomup.BottomUp.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description BottomUp self Source code in ruptures/detection/bottomup.py def fit ( self , signal ) -> \"BottomUp\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params self . cost . fit ( signal ) self . merge . cache_clear () if signal . ndim == 1 : ( n_samples ,) = signal . shape else : n_samples , _ = signal . shape self . n_samples = n_samples self . leaves = self . _grow_tree () return self","title":"fit()"},{"location":"code-reference/detection/bottomup-reference/#ruptures.detection.bottomup.BottomUp.fit_predict","text":"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required n_bkps int number of breakpoints. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/bottomup.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). n_bkps (int): number of breakpoints. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/bottomup-reference/#ruptures.detection.bottomup.BottomUp.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.bottomup.BottomUp.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/bottomup.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.bottomup.BottomUp.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg partition = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"predict()"},{"location":"code-reference/detection/dynp-reference/","text":"Dynamic programming # ruptures.detection.dynp.Dynp # Find optimal change points using dynamic programming. Given a segment model, it computes the best partition for which the sum of errors is minimum. __init__ ( self , model = 'l2' , custom_cost = None , min_size = 2 , jump = 5 , params = None ) special # Creates a Dynp instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. 2 jump int subsample (one every jump points). 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/dynp.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Creates a Dynp instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. jump (int, optional): subsample (one every *jump* points). params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" self . seg = lru_cache ( maxsize = None )( self . _seg ) # dynamic programming if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None fit ( self , signal ) # Create the cache associated with the signal. Dynamic programming is a recurrence; intermediate results are cached to speed up computations. This method sets up the cache. Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Dynp self Source code in ruptures/detection/dynp.py def fit ( self , signal ) -> \"Dynp\" : \"\"\"Create the cache associated with the signal. Dynamic programming is a recurrence; intermediate results are cached to speed up computations. This method sets up the cache. Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # clear cache self . seg . cache_clear () # update some params self . cost . fit ( signal ) self . n_samples = signal . shape [ 0 ] return self fit_predict ( self , signal , n_bkps ) # Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required n_bkps int number of breakpoints. required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/dynp.py def fit_predict ( self , signal , n_bkps ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). n_bkps (int): number of breakpoints. Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( n_bkps ) predict ( self , n_bkps ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.dynp.Dynp.fit]. Parameters: Name Type Description Default n_bkps int number of breakpoints. required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/dynp.py def predict ( self , n_bkps ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.dynp.Dynp.fit]. Args: n_bkps (int): number of breakpoints. Returns: list: sorted list of breakpoints \"\"\" partition = self . seg ( 0 , self . n_samples , n_bkps ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"Dynp"},{"location":"code-reference/detection/dynp-reference/#dynamic-programming","text":"","title":"Dynamic programming"},{"location":"code-reference/detection/dynp-reference/#ruptures.detection.dynp.Dynp","text":"Find optimal change points using dynamic programming. Given a segment model, it computes the best partition for which the sum of errors is minimum.","title":"Dynp"},{"location":"code-reference/detection/dynp-reference/#ruptures.detection.dynp.Dynp.__init__","text":"Creates a Dynp instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. 2 jump int subsample (one every jump points). 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/dynp.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Creates a Dynp instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. jump (int, optional): subsample (one every *jump* points). params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" self . seg = lru_cache ( maxsize = None )( self . _seg ) # dynamic programming if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None","title":"__init__()"},{"location":"code-reference/detection/dynp-reference/#ruptures.detection.dynp.Dynp.fit","text":"Create the cache associated with the signal. Dynamic programming is a recurrence; intermediate results are cached to speed up computations. This method sets up the cache. Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Dynp self Source code in ruptures/detection/dynp.py def fit ( self , signal ) -> \"Dynp\" : \"\"\"Create the cache associated with the signal. Dynamic programming is a recurrence; intermediate results are cached to speed up computations. This method sets up the cache. Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # clear cache self . seg . cache_clear () # update some params self . cost . fit ( signal ) self . n_samples = signal . shape [ 0 ] return self","title":"fit()"},{"location":"code-reference/detection/dynp-reference/#ruptures.detection.dynp.Dynp.fit_predict","text":"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required n_bkps int number of breakpoints. required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/dynp.py def fit_predict ( self , signal , n_bkps ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). n_bkps (int): number of breakpoints. Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( n_bkps )","title":"fit_predict()"},{"location":"code-reference/detection/dynp-reference/#ruptures.detection.dynp.Dynp.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.dynp.Dynp.fit]. Parameters: Name Type Description Default n_bkps int number of breakpoints. required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/dynp.py def predict ( self , n_bkps ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.dynp.Dynp.fit]. Args: n_bkps (int): number of breakpoints. Returns: list: sorted list of breakpoints \"\"\" partition = self . seg ( 0 , self . n_samples , n_bkps ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"predict()"},{"location":"code-reference/detection/greedyar-reference/","text":"Greedy change point detection for piecewise autoregressive signals # ruptures.detection.greedyar.GreedyAR # Greedy change point detection for piecewise autoregressive processes. __init__ ( self , order = 2 , jump = 10 ) special # Parameters: Name Type Description Default order int order of the autoregressive process. Defaults to 2. 2 jump int only consider change points multiple of jump . Defaults to 10. 10 Source code in ruptures/detection/greedyar.py def __init__ ( self , order = 2 , jump = 10 ): \"\"\" Args: order (int, optional): order of the autoregressive process. Defaults to 2. jump (int, optional): only consider change points multiple of *jump*. Defaults to 10. \"\"\" self . order = max ( 1 , order ) self . jump = max ( jump , 2 * ( order + 1 )) self . n_samples = None self . signal = None self . covariates = None self . dim = None fit ( self , signal ) # Compute params to segment signal. Parameters: Name Type Description Default signal array univariate signal to segment. Shape (n_samples, 1) or (n_samples,). required Returns: Type Description GreedyAR self Source code in ruptures/detection/greedyar.py def fit ( self , signal ) -> \"GreedyAR\" : \"\"\"Compute params to segment signal. Args: signal (array): univariate signal to segment. Shape (n_samples, 1) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) - signal . mean () else : self . signal = signal - signal . mean () self . n_samples , dim = self . signal . shape assert dim == 1 , \"Signal must be 1D.\" # covariates are lagged sub-sequences shape = ( self . n_samples - self . order , self . order ) strides = ( self . signal . itemsize , self . signal . itemsize ) covariates = np . lib . stride_tricks . as_strided ( self . signal , shape = shape , strides = strides ) intercept = np . ones ( self . n_samples - self . order ) covariates = np . column_stack (( covariates , intercept )) self . covariates = covariates return self fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ) # Helper method to call fit and predict once. Source code in ruptures/detection/greedyar.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.greedyar.GreedyAR.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/greedyar.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.greedyar.GreedyAR.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return [ b + self . order for b in bkps ] seg ( self , n_bkps = None , pen = None , epsilon = None ) # Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list list of breakpoint indexes Source code in ruptures/detection/greedyar.py def seg ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: list of breakpoint indexes \"\"\" stop = False n_samples = self . n_samples - self . order bkps = [ n_samples ] inds = np . arange ( start = self . jump - self . order , stop = n_samples - self . jump , step = self . jump ) signal = self . signal [ - n_samples :] residual = signal res_norm = residual . var () * n_samples while not stop : # greedy search res_list = list () for ind in inds : # greedy search res_tmp = 0 y_left , y_right = residual [: ind ], residual [ ind :] x_left , x_right = self . covariates [: ind ], self . covariates [ ind :] for x , y in zip (( x_left , x_right ), ( y_left , y_right )): # linear fit _ , res_sub , _ , _ = lstsq ( x , y ) # error on sub-signal res_tmp += res_sub res_list . append ( res_tmp ) # find best index _ , bkp_opt = min ( zip ( res_list , inds )) # orthogonal projection proj = np . zeros ( signal . shape ) for start , end in pairwise ( sorted ([ 0 , bkp_opt ] + bkps )): y = signal [ start : end ] x = self . covariates [ start : end ] coef , _ , _ , _ = lstsq ( x , y ) proj [ start : end ] = x . dot ( coef ) . reshape ( - 1 , 1 ) residual = signal - proj # stopping criterion stop = True if n_bkps is not None : if len ( bkps ) - 1 < n_bkps : stop = False elif pen is not None : if res_norm - residual . var () * n_samples > pen : stop = False elif epsilon is not None : if residual . var () * n_samples > epsilon : stop = False # update if not stop : res_norm = residual . var () * n_samples bkps . append ( bkp_opt ) bkps . sort () return bkps","title":"Greedy change point detection for piecewise autoregressive signals"},{"location":"code-reference/detection/greedyar-reference/#greedy-change-point-detection-for-piecewise-autoregressive-signals","text":"","title":"Greedy change point detection for piecewise autoregressive signals"},{"location":"code-reference/detection/greedyar-reference/#ruptures.detection.greedyar.GreedyAR","text":"Greedy change point detection for piecewise autoregressive processes.","title":"GreedyAR"},{"location":"code-reference/detection/greedyar-reference/#ruptures.detection.greedyar.GreedyAR.__init__","text":"Parameters: Name Type Description Default order int order of the autoregressive process. Defaults to 2. 2 jump int only consider change points multiple of jump . Defaults to 10. 10 Source code in ruptures/detection/greedyar.py def __init__ ( self , order = 2 , jump = 10 ): \"\"\" Args: order (int, optional): order of the autoregressive process. Defaults to 2. jump (int, optional): only consider change points multiple of *jump*. Defaults to 10. \"\"\" self . order = max ( 1 , order ) self . jump = max ( jump , 2 * ( order + 1 )) self . n_samples = None self . signal = None self . covariates = None self . dim = None","title":"__init__()"},{"location":"code-reference/detection/greedyar-reference/#ruptures.detection.greedyar.GreedyAR.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default signal array univariate signal to segment. Shape (n_samples, 1) or (n_samples,). required Returns: Type Description GreedyAR self Source code in ruptures/detection/greedyar.py def fit ( self , signal ) -> \"GreedyAR\" : \"\"\"Compute params to segment signal. Args: signal (array): univariate signal to segment. Shape (n_samples, 1) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) - signal . mean () else : self . signal = signal - signal . mean () self . n_samples , dim = self . signal . shape assert dim == 1 , \"Signal must be 1D.\" # covariates are lagged sub-sequences shape = ( self . n_samples - self . order , self . order ) strides = ( self . signal . itemsize , self . signal . itemsize ) covariates = np . lib . stride_tricks . as_strided ( self . signal , shape = shape , strides = strides ) intercept = np . ones ( self . n_samples - self . order ) covariates = np . column_stack (( covariates , intercept )) self . covariates = covariates return self","title":"fit()"},{"location":"code-reference/detection/greedyar-reference/#ruptures.detection.greedyar.GreedyAR.fit_predict","text":"Helper method to call fit and predict once. Source code in ruptures/detection/greedyar.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/greedyar-reference/#ruptures.detection.greedyar.GreedyAR.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.greedyar.GreedyAR.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/greedyar.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.greedyar.GreedyAR.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return [ b + self . order for b in bkps ]","title":"predict()"},{"location":"code-reference/detection/greedyar-reference/#ruptures.detection.greedyar.GreedyAR.seg","text":"Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list list of breakpoint indexes Source code in ruptures/detection/greedyar.py def seg ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: list of breakpoint indexes \"\"\" stop = False n_samples = self . n_samples - self . order bkps = [ n_samples ] inds = np . arange ( start = self . jump - self . order , stop = n_samples - self . jump , step = self . jump ) signal = self . signal [ - n_samples :] residual = signal res_norm = residual . var () * n_samples while not stop : # greedy search res_list = list () for ind in inds : # greedy search res_tmp = 0 y_left , y_right = residual [: ind ], residual [ ind :] x_left , x_right = self . covariates [: ind ], self . covariates [ ind :] for x , y in zip (( x_left , x_right ), ( y_left , y_right )): # linear fit _ , res_sub , _ , _ = lstsq ( x , y ) # error on sub-signal res_tmp += res_sub res_list . append ( res_tmp ) # find best index _ , bkp_opt = min ( zip ( res_list , inds )) # orthogonal projection proj = np . zeros ( signal . shape ) for start , end in pairwise ( sorted ([ 0 , bkp_opt ] + bkps )): y = signal [ start : end ] x = self . covariates [ start : end ] coef , _ , _ , _ = lstsq ( x , y ) proj [ start : end ] = x . dot ( coef ) . reshape ( - 1 , 1 ) residual = signal - proj # stopping criterion stop = True if n_bkps is not None : if len ( bkps ) - 1 < n_bkps : stop = False elif pen is not None : if res_norm - residual . var () * n_samples > pen : stop = False elif epsilon is not None : if residual . var () * n_samples > epsilon : stop = False # update if not stop : res_norm = residual . var () * n_samples bkps . append ( bkp_opt ) bkps . sort () return bkps","title":"seg()"},{"location":"code-reference/detection/greedylinear-reference/","text":"Greedy change point detection for piecewise linear signals # ruptures.detection.greedylinear.GreedyLinear # Greedy change point detection for piecewise linear processes. __init__ ( self , jump = 10 ) special # Parameters: Name Type Description Default jump int only consider change points multiple of jump . Defaults to 10. 10 Source code in ruptures/detection/greedylinear.py def __init__ ( self , jump = 10 ): \"\"\" Args: jump (int, optional): only consider change points multiple of *jump*. Defaults to 10. \"\"\" self . jump = jump self . n_samples = None self . signal = None self . covariates = None self . dim = None fit ( self , signal , covariates ) # Compute params to segment signal. Parameters: Name Type Description Default signal array univariate signal to segment. Shape (n_samples, 1) or (n_samples,). required covariates array covariates. Shape (n_samples, n_features). required Returns: Type Description GreedyLinear self Source code in ruptures/detection/greedylinear.py def fit ( self , signal , covariates ) -> \"GreedyLinear\" : \"\"\"Compute params to segment signal. Args: signal (array): univariate signal to segment. Shape (n_samples, 1) or (n_samples,). covariates (array): covariates. Shape (n_samples, n_features). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) - signal . mean () else : self . signal = signal - signal . mean () self . n_samples , dim = self . signal . shape assert dim == 1 , \"Signal must be 1D.\" self . covariates = covariates _ , self . dim = self . covariates . shape assert covariates . ndim == 2 , \"Reshape the covariates.\" assert covariates . shape [ 0 ] == self . n_samples , \"Check size.\" return self fit_predict ( self , signal , covariates , n_bkps = None , pen = None , epsilon = None ) # Helper method to call fit and predict once. Source code in ruptures/detection/greedylinear.py def fit_predict ( self , signal , covariates , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal , covariates ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.greedylinear.GreedyLinear.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/greedylinear.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.greedylinear.GreedyLinear.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps seg ( self , n_bkps = None , pen = None , epsilon = None ) # Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list list of breakpoint indexes Source code in ruptures/detection/greedylinear.py def seg ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: list of breakpoint indexes \"\"\" stop = False bkps = [ self . n_samples ] inds = np . arange ( self . jump , self . n_samples - self . jump , self . jump ) residual = self . signal res_norm = residual . var () * self . n_samples while not stop : # greedy search res_list = list () for ind in inds : # greedy search res_tmp = 0 y_left , y_right = residual [: ind ], residual [ ind :] x_left , x_right = self . covariates [: ind ], self . covariates [ ind :] for x , y in zip (( x_left , x_right ), ( y_left , y_right )): # linear fit _ , res_sub , _ , _ = lstsq ( x , y ) # error on sub-signal res_tmp += res_sub res_list . append ( res_tmp ) # find best index _ , bkp_opt = min ( zip ( res_list , inds )) # orthogonal projection proj = np . zeros ( self . signal . shape ) for start , end in pairwise ( sorted ([ 0 , bkp_opt ] + bkps )): y = self . signal [ start : end ] x = self . covariates [ start : end ] coef , _ , _ , _ = lstsq ( x , y ) proj [ start : end ] = x . dot ( coef ) . reshape ( - 1 , 1 ) residual = self . signal - proj # stopping criterion stop = True if n_bkps is not None : if len ( bkps ) - 1 < n_bkps : stop = False elif pen is not None : if res_norm - residual . var () * self . n_samples > pen : stop = False elif epsilon is not None : if residual . var () * self . n_samples > epsilon : stop = False # update if not stop : res_norm = residual . var () * self . n_samples bkps . append ( bkp_opt ) bkps . sort () return bkps","title":"Greedy change point detection for piecewise linear signals"},{"location":"code-reference/detection/greedylinear-reference/#greedy-change-point-detection-for-piecewise-linear-signals","text":"","title":"Greedy change point detection for piecewise linear signals"},{"location":"code-reference/detection/greedylinear-reference/#ruptures.detection.greedylinear.GreedyLinear","text":"Greedy change point detection for piecewise linear processes.","title":"GreedyLinear"},{"location":"code-reference/detection/greedylinear-reference/#ruptures.detection.greedylinear.GreedyLinear.__init__","text":"Parameters: Name Type Description Default jump int only consider change points multiple of jump . Defaults to 10. 10 Source code in ruptures/detection/greedylinear.py def __init__ ( self , jump = 10 ): \"\"\" Args: jump (int, optional): only consider change points multiple of *jump*. Defaults to 10. \"\"\" self . jump = jump self . n_samples = None self . signal = None self . covariates = None self . dim = None","title":"__init__()"},{"location":"code-reference/detection/greedylinear-reference/#ruptures.detection.greedylinear.GreedyLinear.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default signal array univariate signal to segment. Shape (n_samples, 1) or (n_samples,). required covariates array covariates. Shape (n_samples, n_features). required Returns: Type Description GreedyLinear self Source code in ruptures/detection/greedylinear.py def fit ( self , signal , covariates ) -> \"GreedyLinear\" : \"\"\"Compute params to segment signal. Args: signal (array): univariate signal to segment. Shape (n_samples, 1) or (n_samples,). covariates (array): covariates. Shape (n_samples, n_features). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) - signal . mean () else : self . signal = signal - signal . mean () self . n_samples , dim = self . signal . shape assert dim == 1 , \"Signal must be 1D.\" self . covariates = covariates _ , self . dim = self . covariates . shape assert covariates . ndim == 2 , \"Reshape the covariates.\" assert covariates . shape [ 0 ] == self . n_samples , \"Check size.\" return self","title":"fit()"},{"location":"code-reference/detection/greedylinear-reference/#ruptures.detection.greedylinear.GreedyLinear.fit_predict","text":"Helper method to call fit and predict once. Source code in ruptures/detection/greedylinear.py def fit_predict ( self , signal , covariates , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal , covariates ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/greedylinear-reference/#ruptures.detection.greedylinear.GreedyLinear.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.greedylinear.GreedyLinear.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/greedylinear.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.greedylinear.GreedyLinear.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"predict()"},{"location":"code-reference/detection/greedylinear-reference/#ruptures.detection.greedylinear.GreedyLinear.seg","text":"Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list list of breakpoint indexes Source code in ruptures/detection/greedylinear.py def seg ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Computes the greedy segmentation. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: list of breakpoint indexes \"\"\" stop = False bkps = [ self . n_samples ] inds = np . arange ( self . jump , self . n_samples - self . jump , self . jump ) residual = self . signal res_norm = residual . var () * self . n_samples while not stop : # greedy search res_list = list () for ind in inds : # greedy search res_tmp = 0 y_left , y_right = residual [: ind ], residual [ ind :] x_left , x_right = self . covariates [: ind ], self . covariates [ ind :] for x , y in zip (( x_left , x_right ), ( y_left , y_right )): # linear fit _ , res_sub , _ , _ = lstsq ( x , y ) # error on sub-signal res_tmp += res_sub res_list . append ( res_tmp ) # find best index _ , bkp_opt = min ( zip ( res_list , inds )) # orthogonal projection proj = np . zeros ( self . signal . shape ) for start , end in pairwise ( sorted ([ 0 , bkp_opt ] + bkps )): y = self . signal [ start : end ] x = self . covariates [ start : end ] coef , _ , _ , _ = lstsq ( x , y ) proj [ start : end ] = x . dot ( coef ) . reshape ( - 1 , 1 ) residual = self . signal - proj # stopping criterion stop = True if n_bkps is not None : if len ( bkps ) - 1 < n_bkps : stop = False elif pen is not None : if res_norm - residual . var () * self . n_samples > pen : stop = False elif epsilon is not None : if residual . var () * self . n_samples > epsilon : stop = False # update if not stop : res_norm = residual . var () * self . n_samples bkps . append ( bkp_opt ) bkps . sort () return bkps","title":"seg()"},{"location":"code-reference/detection/omp-reference/","text":"Orthogonal matching pursuit for changepoint detection # ruptures.detection.omp.Omp # Contient l'algorithme de parcours des partitions. __init__ ( self , min_size = 2 , jump = 5 ) special # Initialize an Omp instance. Parameters: Name Type Description Default min_size int minimum segment length. Defaults to 2 samples. 2 jump int subsample (one every \"jump\" points). Defaults to 5 samples. 5 Source code in ruptures/detection/omp.py def __init__ ( self , min_size = 2 , jump = 5 ): \"\"\"Initialize an Omp instance. Args: min_size (int, optional): minimum segment length. Defaults to 2 samples. jump (int, optional): subsample (one every \"jump\" points). Defaults to 5 samples. \"\"\" self . min_size = min_size # not used self . jump = jump # not used self . n_samples = None self . signal = None fit ( self , signal ) # Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Omp self Source code in ruptures/detection/omp.py def fit ( self , signal ) -> \"Omp\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal self . signal = self . signal - self . signal . mean ( axis = 0 ) self . n_samples , _ = self . signal . shape return self fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ) # Helper method to call fit and predict once. Source code in ruptures/detection/omp.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.omp.Omp.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/omp.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.omp.Omp.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"Orthogonal matching pursuit for changepoint detection"},{"location":"code-reference/detection/omp-reference/#orthogonal-matching-pursuit-for-changepoint-detection","text":"","title":"Orthogonal matching pursuit for changepoint detection"},{"location":"code-reference/detection/omp-reference/#ruptures.detection.omp.Omp","text":"Contient l'algorithme de parcours des partitions.","title":"Omp"},{"location":"code-reference/detection/omp-reference/#ruptures.detection.omp.Omp.__init__","text":"Initialize an Omp instance. Parameters: Name Type Description Default min_size int minimum segment length. Defaults to 2 samples. 2 jump int subsample (one every \"jump\" points). Defaults to 5 samples. 5 Source code in ruptures/detection/omp.py def __init__ ( self , min_size = 2 , jump = 5 ): \"\"\"Initialize an Omp instance. Args: min_size (int, optional): minimum segment length. Defaults to 2 samples. jump (int, optional): subsample (one every \"jump\" points). Defaults to 5 samples. \"\"\" self . min_size = min_size # not used self . jump = jump # not used self . n_samples = None self . signal = None","title":"__init__()"},{"location":"code-reference/detection/omp-reference/#ruptures.detection.omp.Omp.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Omp self Source code in ruptures/detection/omp.py def fit ( self , signal ) -> \"Omp\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal self . signal = self . signal - self . signal . mean ( axis = 0 ) self . n_samples , _ = self . signal . shape return self","title":"fit()"},{"location":"code-reference/detection/omp-reference/#ruptures.detection.omp.Omp.fit_predict","text":"Helper method to call fit and predict once. Source code in ruptures/detection/omp.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/omp-reference/#ruptures.detection.omp.Omp.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.omp.Omp.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/omp.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.omp.Omp.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"predict()"},{"location":"code-reference/detection/ompk-reference/","text":"Kernel orthogonal matching pursuit for changepoint detection # ruptures.detection.ompk.OmpK # Contient l'algorithme de parcours des partitions. __init__ ( self , min_size = 2 , jump = 5 ) special # One line description. Detailled description Parameters: Name Type Description Default min_size int minimum segment length 2 jump int subsample (one every \"jump\" points) 5 Source code in ruptures/detection/ompk.py def __init__ ( self , min_size = 2 , jump = 5 ): \"\"\"One line description. Detailled description Args: min_size (int, optional): minimum segment length jump (int, optional): subsample (one every \"jump\" points) \"\"\" self . min_size = min_size # not used self . jump = jump # not used self . n_samples = None self . gram = None fit ( self , gram ) # Compute params to segment signal. Parameters: Name Type Description Default gram array Gram matrix of signal to segment. Shape (n_samples, n_samples). required Returns: Type Description OmpK self Source code in ruptures/detection/ompk.py def fit ( self , gram ) -> \"OmpK\" : \"\"\"Compute params to segment signal. Args: gram (array): Gram matrix of signal to segment. Shape (n_samples, n_samples). Returns: self \"\"\" assert gram . shape [ 0 ] == gram . shape [ 1 ], \"Not a square matrix.\" # update some params self . gram = gram self . n_samples , _ = self . gram . shape return self fit_predict ( self , gram , n_bkps = None , pen = None , epsilon = None ) # Helper method to call fit and predict once. Source code in ruptures/detection/ompk.py def fit_predict ( self , gram , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( gram ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.ompk.OmpK.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/ompk.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.ompk.OmpK.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"Kernel orthogonal matching pursuit for changepoint detection"},{"location":"code-reference/detection/ompk-reference/#kernel-orthogonal-matching-pursuit-for-changepoint-detection","text":"","title":"Kernel orthogonal matching pursuit for changepoint detection"},{"location":"code-reference/detection/ompk-reference/#ruptures.detection.ompk.OmpK","text":"Contient l'algorithme de parcours des partitions.","title":"OmpK"},{"location":"code-reference/detection/ompk-reference/#ruptures.detection.ompk.OmpK.__init__","text":"One line description. Detailled description Parameters: Name Type Description Default min_size int minimum segment length 2 jump int subsample (one every \"jump\" points) 5 Source code in ruptures/detection/ompk.py def __init__ ( self , min_size = 2 , jump = 5 ): \"\"\"One line description. Detailled description Args: min_size (int, optional): minimum segment length jump (int, optional): subsample (one every \"jump\" points) \"\"\" self . min_size = min_size # not used self . jump = jump # not used self . n_samples = None self . gram = None","title":"__init__()"},{"location":"code-reference/detection/ompk-reference/#ruptures.detection.ompk.OmpK.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default gram array Gram matrix of signal to segment. Shape (n_samples, n_samples). required Returns: Type Description OmpK self Source code in ruptures/detection/ompk.py def fit ( self , gram ) -> \"OmpK\" : \"\"\"Compute params to segment signal. Args: gram (array): Gram matrix of signal to segment. Shape (n_samples, n_samples). Returns: self \"\"\" assert gram . shape [ 0 ] == gram . shape [ 1 ], \"Not a square matrix.\" # update some params self . gram = gram self . n_samples , _ = self . gram . shape return self","title":"fit()"},{"location":"code-reference/detection/ompk-reference/#ruptures.detection.ompk.OmpK.fit_predict","text":"Helper method to call fit and predict once. Source code in ruptures/detection/ompk.py def fit_predict ( self , gram , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( gram ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/ompk-reference/#ruptures.detection.ompk.OmpK.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.ompk.OmpK.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/ompk.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.ompk.OmpK.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"predict()"},{"location":"code-reference/detection/pelt-reference/","text":"Pelt # ruptures.detection.pelt.Pelt # Penalized change point detection. For a given model and penalty level, computes the segmentation which minimizes the constrained sum of approximation errors. __init__ ( self , model = 'l2' , custom_cost = None , min_size = 2 , jump = 5 , params = None ) special # Initialize a Pelt instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. 2 jump int subsample (one every jump points). 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/pelt.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Initialize a Pelt instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. jump (int, optional): subsample (one every *jump* points). params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None fit ( self , signal ) # Set params. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Pelt self Source code in ruptures/detection/pelt.py def fit ( self , signal ) -> \"Pelt\" : \"\"\"Set params. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update params self . cost . fit ( signal ) if signal . ndim == 1 : ( n_samples ,) = signal . shape else : n_samples , _ = signal . shape self . n_samples = n_samples return self fit_predict ( self , signal , pen ) # Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required pen float penalty value (>0) required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/pelt.py def fit_predict ( self , signal , pen ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). pen (float): penalty value (>0) Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( pen ) predict ( self , pen ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.pelt.Pelt.fit]. Parameters: Name Type Description Default pen float penalty value (>0) required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/pelt.py def predict ( self , pen ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.pelt.Pelt.fit]. Args: pen (float): penalty value (>0) Returns: list: sorted list of breakpoints \"\"\" partition = self . _seg ( pen ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"Pelt"},{"location":"code-reference/detection/pelt-reference/#pelt","text":"","title":"Pelt"},{"location":"code-reference/detection/pelt-reference/#ruptures.detection.pelt.Pelt","text":"Penalized change point detection. For a given model and penalty level, computes the segmentation which minimizes the constrained sum of approximation errors.","title":"Pelt"},{"location":"code-reference/detection/pelt-reference/#ruptures.detection.pelt.Pelt.__init__","text":"Initialize a Pelt instance. Parameters: Name Type Description Default model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if 'custom_cost' is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. 2 jump int subsample (one every jump points). 5 params dict a dictionary of parameters for the cost instance. None Source code in ruptures/detection/pelt.py def __init__ ( self , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Initialize a Pelt instance. Args: model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if ``'custom_cost'`` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. jump (int, optional): subsample (one every *jump* points). params (dict, optional): a dictionary of parameters for the cost instance. \"\"\" if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . min_size = max ( min_size , self . cost . min_size ) self . jump = jump self . n_samples = None","title":"__init__()"},{"location":"code-reference/detection/pelt-reference/#ruptures.detection.pelt.Pelt.fit","text":"Set params. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Pelt self Source code in ruptures/detection/pelt.py def fit ( self , signal ) -> \"Pelt\" : \"\"\"Set params. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update params self . cost . fit ( signal ) if signal . ndim == 1 : ( n_samples ,) = signal . shape else : n_samples , _ = signal . shape self . n_samples = n_samples return self","title":"fit()"},{"location":"code-reference/detection/pelt-reference/#ruptures.detection.pelt.Pelt.fit_predict","text":"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Parameters: Name Type Description Default signal array signal. Shape (n_samples, n_features) or (n_samples,). required pen float penalty value (>0) required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/pelt.py def fit_predict ( self , signal , pen ): \"\"\"Fit to the signal and return the optimal breakpoints. Helper method to call fit and predict once Args: signal (array): signal. Shape (n_samples, n_features) or (n_samples,). pen (float): penalty value (>0) Returns: list: sorted list of breakpoints \"\"\" self . fit ( signal ) return self . predict ( pen )","title":"fit_predict()"},{"location":"code-reference/detection/pelt-reference/#ruptures.detection.pelt.Pelt.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.pelt.Pelt.fit]. Parameters: Name Type Description Default pen float penalty value (>0) required Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/pelt.py def predict ( self , pen ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.pelt.Pelt.fit]. Args: pen (float): penalty value (>0) Returns: list: sorted list of breakpoints \"\"\" partition = self . _seg ( pen ) bkps = sorted ( e for s , e in partition . keys ()) return bkps","title":"predict()"},{"location":"code-reference/detection/window-reference/","text":"Window-based change point detection # ruptures.detection.window.Window # Window sliding method. __init__ ( self , width = 100 , model = 'l2' , custom_cost = None , min_size = 2 , jump = 5 , params = None ) special # Instanciate with window length. Parameters: Name Type Description Default width int window length. Defaults to 100 samples. 100 model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if custom_cost is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. 2 jump int subsample (one every jump points). 5 params dict a dictionary of parameters for the cost instance.` None Source code in ruptures/detection/window.py def __init__ ( self , width = 100 , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Instanciate with window length. Args: width (int, optional): window length. Defaults to 100 samples. model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if `custom_cost` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. jump (int, optional): subsample (one every *jump* points). params (dict, optional): a dictionary of parameters for the cost instance.` \"\"\" self . min_size = min_size self . jump = jump self . width = 2 * ( width // 2 ) self . n_samples = None self . signal = None self . inds = None if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . score = list () fit ( self , signal ) # Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Window self Source code in ruptures/detection/window.py def fit ( self , signal ) -> \"Window\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal self . n_samples , _ = self . signal . shape # indexes self . inds = np . arange ( self . n_samples , step = self . jump ) # delete borders keep = ( self . inds >= self . width // 2 ) & ( self . inds < self . n_samples - self . width // 2 ) self . inds = self . inds [ keep ] self . cost . fit ( signal ) # compute score score = list () for k in self . inds : start , end = k - self . width // 2 , k + self . width // 2 gain = self . cost . error ( start , end ) gain -= self . cost . error ( start , k ) + self . cost . error ( k , end ) score . append ( gain ) self . score = np . array ( score ) return self fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ) # Helper method to call fit and predict once. Source code in ruptures/detection/window.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) predict ( self , n_bkps = None , pen = None , epsilon = None ) # Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.window.Window.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/window.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.window.Window.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"Window"},{"location":"code-reference/detection/window-reference/#window-based-change-point-detection","text":"","title":"Window-based change point detection"},{"location":"code-reference/detection/window-reference/#ruptures.detection.window.Window","text":"Window sliding method.","title":"Window"},{"location":"code-reference/detection/window-reference/#ruptures.detection.window.Window.__init__","text":"Instanciate with window length. Parameters: Name Type Description Default width int window length. Defaults to 100 samples. 100 model str segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if custom_cost is not None. 'l2' custom_cost BaseCost custom cost function. Defaults to None. None min_size int minimum segment length. 2 jump int subsample (one every jump points). 5 params dict a dictionary of parameters for the cost instance.` None Source code in ruptures/detection/window.py def __init__ ( self , width = 100 , model = \"l2\" , custom_cost = None , min_size = 2 , jump = 5 , params = None ): \"\"\"Instanciate with window length. Args: width (int, optional): window length. Defaults to 100 samples. model (str, optional): segment model, [\"l1\", \"l2\", \"rbf\"]. Not used if `custom_cost` is not None. custom_cost (BaseCost, optional): custom cost function. Defaults to None. min_size (int, optional): minimum segment length. jump (int, optional): subsample (one every *jump* points). params (dict, optional): a dictionary of parameters for the cost instance.` \"\"\" self . min_size = min_size self . jump = jump self . width = 2 * ( width // 2 ) self . n_samples = None self . signal = None self . inds = None if custom_cost is not None and isinstance ( custom_cost , BaseCost ): self . cost = custom_cost else : if params is None : self . cost = cost_factory ( model = model ) else : self . cost = cost_factory ( model = model , ** params ) self . score = list ()","title":"__init__()"},{"location":"code-reference/detection/window-reference/#ruptures.detection.window.Window.fit","text":"Compute params to segment signal. Parameters: Name Type Description Default signal array signal to segment. Shape (n_samples, n_features) or (n_samples,). required Returns: Type Description Window self Source code in ruptures/detection/window.py def fit ( self , signal ) -> \"Window\" : \"\"\"Compute params to segment signal. Args: signal (array): signal to segment. Shape (n_samples, n_features) or (n_samples,). Returns: self \"\"\" # update some params if signal . ndim == 1 : self . signal = signal . reshape ( - 1 , 1 ) else : self . signal = signal self . n_samples , _ = self . signal . shape # indexes self . inds = np . arange ( self . n_samples , step = self . jump ) # delete borders keep = ( self . inds >= self . width // 2 ) & ( self . inds < self . n_samples - self . width // 2 ) self . inds = self . inds [ keep ] self . cost . fit ( signal ) # compute score score = list () for k in self . inds : start , end = k - self . width // 2 , k + self . width // 2 gain = self . cost . error ( start , end ) gain -= self . cost . error ( start , k ) + self . cost . error ( k , end ) score . append ( gain ) self . score = np . array ( score ) return self","title":"fit()"},{"location":"code-reference/detection/window-reference/#ruptures.detection.window.Window.fit_predict","text":"Helper method to call fit and predict once. Source code in ruptures/detection/window.py def fit_predict ( self , signal , n_bkps = None , pen = None , epsilon = None ): \"\"\"Helper method to call fit and predict once.\"\"\" self . fit ( signal ) return self . predict ( n_bkps = n_bkps , pen = pen , epsilon = epsilon )","title":"fit_predict()"},{"location":"code-reference/detection/window-reference/#ruptures.detection.window.Window.predict","text":"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [ fit() ][ruptures.detection.window.Window.fit]. The stopping rule depends on the parameter passed to the function. Parameters: Name Type Description Default n_bkps int number of breakpoints to find before stopping. None pen float penalty value (>0) None epsilon float reconstruction budget (>0) None Returns: Type Description list sorted list of breakpoints Source code in ruptures/detection/window.py def predict ( self , n_bkps = None , pen = None , epsilon = None ): \"\"\"Return the optimal breakpoints. Must be called after the fit method. The breakpoints are associated with the signal passed to [`fit()`][ruptures.detection.window.Window.fit]. The stopping rule depends on the parameter passed to the function. Args: n_bkps (int): number of breakpoints to find before stopping. pen (float): penalty value (>0) epsilon (float): reconstruction budget (>0) Returns: list: sorted list of breakpoints \"\"\" msg = \"Give a parameter.\" assert any ( param is not None for param in ( n_bkps , pen , epsilon )), msg bkps = self . _seg ( n_bkps = n_bkps , pen = pen , epsilon = epsilon ) return bkps","title":"predict()"},{"location":"code-reference/metrics/hausdorff/","text":"Hausdorff metric ( hausdorff ) # ruptures.metrics.hausdorff.hausdorff ( bkps1 , bkps2 ) # Compute the Hausdorff distance between changepoints. Parameters: Name Type Description Default bkps1 list list of the last index of each regime. required bkps2 list list of the last index of each regime. required Returns: Type Description float Hausdorff distance. Source code in ruptures/metrics/hausdorff.py def hausdorff ( bkps1 , bkps2 ): \"\"\"Compute the Hausdorff distance between changepoints. Args: bkps1 (list): list of the last index of each regime. bkps2 (list): list of the last index of each regime. Returns: float: Hausdorff distance. \"\"\" sanity_check ( bkps1 , bkps2 ) bkps1_arr = np . array ( bkps1 [: - 1 ]) . reshape ( - 1 , 1 ) bkps2_arr = np . array ( bkps2 [: - 1 ]) . reshape ( - 1 , 1 ) pw_dist = cdist ( bkps1_arr , bkps2_arr ) res = max ( pw_dist . min ( axis = 0 ) . max (), pw_dist . min ( axis = 1 ) . max ()) return res","title":"Hausdorff metric"},{"location":"code-reference/metrics/hausdorff/#hausdorff-metric-hausdorff","text":"","title":"Hausdorff metric (hausdorff)"},{"location":"code-reference/metrics/hausdorff/#ruptures.metrics.hausdorff.hausdorff","text":"Compute the Hausdorff distance between changepoints. Parameters: Name Type Description Default bkps1 list list of the last index of each regime. required bkps2 list list of the last index of each regime. required Returns: Type Description float Hausdorff distance. Source code in ruptures/metrics/hausdorff.py def hausdorff ( bkps1 , bkps2 ): \"\"\"Compute the Hausdorff distance between changepoints. Args: bkps1 (list): list of the last index of each regime. bkps2 (list): list of the last index of each regime. Returns: float: Hausdorff distance. \"\"\" sanity_check ( bkps1 , bkps2 ) bkps1_arr = np . array ( bkps1 [: - 1 ]) . reshape ( - 1 , 1 ) bkps2_arr = np . array ( bkps2 [: - 1 ]) . reshape ( - 1 , 1 ) pw_dist = cdist ( bkps1_arr , bkps2_arr ) res = max ( pw_dist . min ( axis = 0 ) . max (), pw_dist . min ( axis = 1 ) . max ()) return res","title":"hausdorff()"},{"location":"code-reference/metrics/precisionrecall/","text":"Precision and recall ( precision_recall ) # ruptures.metrics.precisionrecall.precision_recall ( true_bkps , my_bkps , margin = 10 ) # Calculate the precision/recall of an estimated segmentation compared with the true segmentation. Parameters: Name Type Description Default true_bkps list list of the last index of each regime (true partition). required my_bkps list list of the last index of each regime (computed partition). required margin int allowed error (in points). 10 Returns: Type Description tuple (precision, recall) Source code in ruptures/metrics/precisionrecall.py def precision_recall ( true_bkps , my_bkps , margin = 10 ): \"\"\"Calculate the precision/recall of an estimated segmentation compared with the true segmentation. Args: true_bkps (list): list of the last index of each regime (true partition). my_bkps (list): list of the last index of each regime (computed partition). margin (int, optional): allowed error (in points). Returns: tuple: (precision, recall) \"\"\" sanity_check ( true_bkps , my_bkps ) assert margin > 0 , \"Margin of error must be positive (margin = {} )\" . format ( margin ) if len ( my_bkps ) == 1 : return 0 , 0 used = set () true_pos = set ( true_b for true_b , my_b in product ( true_bkps [: - 1 ], my_bkps [: - 1 ]) if my_b - margin < true_b < my_b + margin and not ( my_b in used or used . add ( my_b )) ) tp_ = len ( true_pos ) precision = tp_ / ( len ( my_bkps ) - 1 ) recall = tp_ / ( len ( true_bkps ) - 1 ) return precision , recall","title":"Precision and recall"},{"location":"code-reference/metrics/precisionrecall/#precision-and-recall-precision_recall","text":"","title":"Precision and recall (precision_recall)"},{"location":"code-reference/metrics/precisionrecall/#ruptures.metrics.precisionrecall.precision_recall","text":"Calculate the precision/recall of an estimated segmentation compared with the true segmentation. Parameters: Name Type Description Default true_bkps list list of the last index of each regime (true partition). required my_bkps list list of the last index of each regime (computed partition). required margin int allowed error (in points). 10 Returns: Type Description tuple (precision, recall) Source code in ruptures/metrics/precisionrecall.py def precision_recall ( true_bkps , my_bkps , margin = 10 ): \"\"\"Calculate the precision/recall of an estimated segmentation compared with the true segmentation. Args: true_bkps (list): list of the last index of each regime (true partition). my_bkps (list): list of the last index of each regime (computed partition). margin (int, optional): allowed error (in points). Returns: tuple: (precision, recall) \"\"\" sanity_check ( true_bkps , my_bkps ) assert margin > 0 , \"Margin of error must be positive (margin = {} )\" . format ( margin ) if len ( my_bkps ) == 1 : return 0 , 0 used = set () true_pos = set ( true_b for true_b , my_b in product ( true_bkps [: - 1 ], my_bkps [: - 1 ]) if my_b - margin < true_b < my_b + margin and not ( my_b in used or used . add ( my_b )) ) tp_ = len ( true_pos ) precision = tp_ / ( len ( my_bkps ) - 1 ) recall = tp_ / ( len ( true_bkps ) - 1 ) return precision , recall","title":"precision_recall()"},{"location":"code-reference/metrics/randindex/","text":"Rand index ( randindex ) # ruptures.metrics.randindex.randindex ( bkps1 , bkps2 ) # Rand index for two partitions. The result is scaled to be within 0 and 1. Parameters: Name Type Description Default bkps1 list list of the last index of each regime. required bkps2 list list of the last index of each regime. required Returns: Type Description float Rand index Source code in ruptures/metrics/randindex.py def randindex ( bkps1 , bkps2 ): \"\"\"Rand index for two partitions. The result is scaled to be within 0 and 1. Args: bkps1 (list): list of the last index of each regime. bkps2 (list): list of the last index of each regime. Returns: float: Rand index \"\"\" return 1 - hamming ( bkps1 , bkps2 )","title":"Rand index"},{"location":"code-reference/metrics/randindex/#rand-index-randindex","text":"","title":"Rand index (randindex)"},{"location":"code-reference/metrics/randindex/#ruptures.metrics.randindex.randindex","text":"Rand index for two partitions. The result is scaled to be within 0 and 1. Parameters: Name Type Description Default bkps1 list list of the last index of each regime. required bkps2 list list of the last index of each regime. required Returns: Type Description float Rand index Source code in ruptures/metrics/randindex.py def randindex ( bkps1 , bkps2 ): \"\"\"Rand index for two partitions. The result is scaled to be within 0 and 1. Args: bkps1 (list): list of the last index of each regime. bkps2 (list): list of the last index of each regime. Returns: float: Rand index \"\"\" return 1 - hamming ( bkps1 , bkps2 )","title":"randindex()"},{"location":"code-reference/show/display/","text":"Display ( display ) # ruptures.show.display.display ( signal , true_chg_pts , computed_chg_pts = None , ** kwargs ) # Display a signal and the change points provided in alternating colors. If another set of change point is provided, they are displayed with dashed vertical dashed lines. The following matplotlib subplots options is set by default, but can be changed when calling display ): figure size figsize , defaults to (10, 2 * n_features) . Parameters: Name Type Description Default signal array signal array, shape (n_samples,) or (n_samples, n_features). required true_chg_pts list list of change point indexes. required computed_chg_pts list list of change point indexes. None **kwargs all additional keyword arguments are passed to the plt.subplots call. {} Returns: Type Description tuple (figure, axarr) with a :class: matplotlib.figure.Figure object and an array of Axes objects. Source code in ruptures/show/display.py def display ( signal , true_chg_pts , computed_chg_pts = None , ** kwargs ): \"\"\"Display a signal and the change points provided in alternating colors. If another set of change point is provided, they are displayed with dashed vertical dashed lines. The following matplotlib subplots options is set by default, but can be changed when calling `display`): - figure size `figsize`, defaults to `(10, 2 * n_features)`. Args: signal (array): signal array, shape (n_samples,) or (n_samples, n_features). true_chg_pts (list): list of change point indexes. computed_chg_pts (list, optional): list of change point indexes. **kwargs : all additional keyword arguments are passed to the plt.subplots call. Returns: tuple: (figure, axarr) with a :class:`matplotlib.figure.Figure` object and an array of Axes objects. \"\"\" try : import matplotlib.pyplot as plt except ImportError : raise MatplotlibMissingError ( \"This feature requires the optional dependency matpotlib, you can install it using `pip install matplotlib`.\" ) if type ( signal ) != np . ndarray : # Try to get array from Pandas dataframe signal = signal . values if signal . ndim == 1 : signal = signal . reshape ( - 1 , 1 ) n_samples , n_features = signal . shape # let's set a sensible defaut size for the subplots matplotlib_options = { \"figsize\" : ( 10 , 2 * n_features ), # figure size } # add/update the options given by the user matplotlib_options . update ( kwargs ) # create plots fig , axarr = plt . subplots ( n_features , sharex = True , ** matplotlib_options ) if n_features == 1 : axarr = [ axarr ] for axe , sig in zip ( axarr , signal . T ): color_cycle = cycle ( COLOR_CYCLE ) # plot s axe . plot ( range ( n_samples ), sig ) # color each (true) regime bkps = [ 0 ] + sorted ( true_chg_pts ) alpha = 0.2 # transparency of the colored background for ( start , end ), col in zip ( pairwise ( bkps ), color_cycle ): axe . axvspan ( max ( 0 , start - 0.5 ), end - 0.5 , facecolor = col , alpha = alpha ) color = \"k\" # color of the lines indicating the computed_chg_pts linewidth = 3 # linewidth of the lines indicating the computed_chg_pts linestyle = \"--\" # linestyle of the lines indicating the computed_chg_pts # vertical lines to mark the computed_chg_pts if computed_chg_pts is not None : for bkp in computed_chg_pts : if bkp != 0 and bkp < n_samples : axe . axvline ( x = bkp - 0.5 , color = color , linewidth = linewidth , linestyle = linestyle , ) fig . tight_layout () return fig , axarr","title":"Display function"},{"location":"code-reference/show/display/#display-display","text":"","title":"Display (display)"},{"location":"code-reference/show/display/#ruptures.show.display.display","text":"Display a signal and the change points provided in alternating colors. If another set of change point is provided, they are displayed with dashed vertical dashed lines. The following matplotlib subplots options is set by default, but can be changed when calling display ): figure size figsize , defaults to (10, 2 * n_features) . Parameters: Name Type Description Default signal array signal array, shape (n_samples,) or (n_samples, n_features). required true_chg_pts list list of change point indexes. required computed_chg_pts list list of change point indexes. None **kwargs all additional keyword arguments are passed to the plt.subplots call. {} Returns: Type Description tuple (figure, axarr) with a :class: matplotlib.figure.Figure object and an array of Axes objects. Source code in ruptures/show/display.py def display ( signal , true_chg_pts , computed_chg_pts = None , ** kwargs ): \"\"\"Display a signal and the change points provided in alternating colors. If another set of change point is provided, they are displayed with dashed vertical dashed lines. The following matplotlib subplots options is set by default, but can be changed when calling `display`): - figure size `figsize`, defaults to `(10, 2 * n_features)`. Args: signal (array): signal array, shape (n_samples,) or (n_samples, n_features). true_chg_pts (list): list of change point indexes. computed_chg_pts (list, optional): list of change point indexes. **kwargs : all additional keyword arguments are passed to the plt.subplots call. Returns: tuple: (figure, axarr) with a :class:`matplotlib.figure.Figure` object and an array of Axes objects. \"\"\" try : import matplotlib.pyplot as plt except ImportError : raise MatplotlibMissingError ( \"This feature requires the optional dependency matpotlib, you can install it using `pip install matplotlib`.\" ) if type ( signal ) != np . ndarray : # Try to get array from Pandas dataframe signal = signal . values if signal . ndim == 1 : signal = signal . reshape ( - 1 , 1 ) n_samples , n_features = signal . shape # let's set a sensible defaut size for the subplots matplotlib_options = { \"figsize\" : ( 10 , 2 * n_features ), # figure size } # add/update the options given by the user matplotlib_options . update ( kwargs ) # create plots fig , axarr = plt . subplots ( n_features , sharex = True , ** matplotlib_options ) if n_features == 1 : axarr = [ axarr ] for axe , sig in zip ( axarr , signal . T ): color_cycle = cycle ( COLOR_CYCLE ) # plot s axe . plot ( range ( n_samples ), sig ) # color each (true) regime bkps = [ 0 ] + sorted ( true_chg_pts ) alpha = 0.2 # transparency of the colored background for ( start , end ), col in zip ( pairwise ( bkps ), color_cycle ): axe . axvspan ( max ( 0 , start - 0.5 ), end - 0.5 , facecolor = col , alpha = alpha ) color = \"k\" # color of the lines indicating the computed_chg_pts linewidth = 3 # linewidth of the lines indicating the computed_chg_pts linestyle = \"--\" # linestyle of the lines indicating the computed_chg_pts # vertical lines to mark the computed_chg_pts if computed_chg_pts is not None : for bkp in computed_chg_pts : if bkp != 0 and bkp < n_samples : axe . axvline ( x = bkp - 0.5 , color = color , linewidth = linewidth , linestyle = linestyle , ) fig . tight_layout () return fig , axarr","title":"display()"},{"location":"user-guide/","text":"User guide # This section describes the algorithms and utility functions of ruptures . Each entry of the user guide is linked to a companion entry in the Code reference section, where the API is detailed.","title":"Introduction"},{"location":"user-guide/#user-guide","text":"This section describes the algorithms and utility functions of ruptures . Each entry of the user guide is linked to a companion entry in the Code reference section, where the API is detailed.","title":"User guide"},{"location":"user-guide/evaluation/","text":"Evaluation and visualization #","title":"Evaluation and visualization"},{"location":"user-guide/evaluation/#evaluation-and-visualization","text":"","title":"Evaluation and visualization"},{"location":"user-guide/costs/costautoregressive/","text":"Autoregressive model change ( CostAR ) # Description # Let \\(0<t_1<t_2<\\dots<n\\) be unknown change points indexes. Consider the following piecewise autoregressive model \\[ y_t = z_t' \\delta_j + \\varepsilon_t, \\quad \\forall t=t_j,\\dots,t_{j+1}-1 \\] where \\(j>1\\) is the segment number, \\(z_t=[y_{t-1}, y_{t-2},\\dots,y_{t-p}]\\) is the lag vector,and \\(p>0\\) is the order of the process. The least-squares estimates of the break dates is obtained by minimizing the sum of squared residuals [Bai2000] . Formally, the associated cost function on an interval \\(I\\) is \\[ c(y_{I}) = \\min_{\\delta\\in\\mathbb{R}^p} \\sum_{t\\in I} \\|y_t - \\delta' z_t \\|_2^2. \\] Currently, this function is limited to 1D signals. Usage # Start with the usual imports and create a signal with piecewise linear trends. from itertools import cycle import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n = 2000 n_bkps , sigma = 4 , 0.5 # number of change points, noise standart deviation bkps = [ 400 , 1000 , 1300 , 1800 , n ] f1 = np . array ([ 0.075 , 0.1 ]) f2 = np . array ([ 0.1 , 0.125 ]) freqs = np . zeros (( n , 2 )) for sub , val in zip ( np . split ( freqs , bkps [: - 1 ]), cycle ([ f1 , f2 ])): sub += val tt = np . arange ( n ) signal = np . sum (( np . sin ( 2 * np . pi * tt * f ) for f in freqs . T )) signal += np . random . normal ( scale = sigma , size = signal . shape ) # display signal rpt . show . display ( signal , bkps , figsize = ( 10 , 6 )) plt . show () Then create a [CostAR][ruptures.costs.costautoregressive.CostAR] instance and print the cost of the sub-signal signal[50:150] . The autoregressive order can be specified through the keyword 'order' . c = rpt . costs . CostAR ( order = 10 ) . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [BaseEstimator][ruptures.base.BaseEstimator]), either pass a [CostAR][ruptures.costs.costautoregressive.CostAR] instance (through the argument 'custom_cost' ) or set model=\"ar\" . Additional parameters can be passed to the cost instance through the keyword 'params' . c = rpt . costs . CostAR ( order = 10 ); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"ar\" , params = { \"order\" : 10 }) Reference # [Bai2000] Bai, J. (2000). Vector autoregressive models with structural changes in regression coefficients and in variance\u2013covariance matrices. Annals of Economics and Finance, 1(2), 301\u2013336.","title":"CostAR"},{"location":"user-guide/costs/costautoregressive/#autoregressive-model-change-costar","text":"","title":"Autoregressive model change (CostAR)"},{"location":"user-guide/costs/costautoregressive/#description","text":"Let \\(0<t_1<t_2<\\dots<n\\) be unknown change points indexes. Consider the following piecewise autoregressive model \\[ y_t = z_t' \\delta_j + \\varepsilon_t, \\quad \\forall t=t_j,\\dots,t_{j+1}-1 \\] where \\(j>1\\) is the segment number, \\(z_t=[y_{t-1}, y_{t-2},\\dots,y_{t-p}]\\) is the lag vector,and \\(p>0\\) is the order of the process. The least-squares estimates of the break dates is obtained by minimizing the sum of squared residuals [Bai2000] . Formally, the associated cost function on an interval \\(I\\) is \\[ c(y_{I}) = \\min_{\\delta\\in\\mathbb{R}^p} \\sum_{t\\in I} \\|y_t - \\delta' z_t \\|_2^2. \\] Currently, this function is limited to 1D signals.","title":"Description"},{"location":"user-guide/costs/costautoregressive/#usage","text":"Start with the usual imports and create a signal with piecewise linear trends. from itertools import cycle import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n = 2000 n_bkps , sigma = 4 , 0.5 # number of change points, noise standart deviation bkps = [ 400 , 1000 , 1300 , 1800 , n ] f1 = np . array ([ 0.075 , 0.1 ]) f2 = np . array ([ 0.1 , 0.125 ]) freqs = np . zeros (( n , 2 )) for sub , val in zip ( np . split ( freqs , bkps [: - 1 ]), cycle ([ f1 , f2 ])): sub += val tt = np . arange ( n ) signal = np . sum (( np . sin ( 2 * np . pi * tt * f ) for f in freqs . T )) signal += np . random . normal ( scale = sigma , size = signal . shape ) # display signal rpt . show . display ( signal , bkps , figsize = ( 10 , 6 )) plt . show () Then create a [CostAR][ruptures.costs.costautoregressive.CostAR] instance and print the cost of the sub-signal signal[50:150] . The autoregressive order can be specified through the keyword 'order' . c = rpt . costs . CostAR ( order = 10 ) . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [BaseEstimator][ruptures.base.BaseEstimator]), either pass a [CostAR][ruptures.costs.costautoregressive.CostAR] instance (through the argument 'custom_cost' ) or set model=\"ar\" . Additional parameters can be passed to the cost instance through the keyword 'params' . c = rpt . costs . CostAR ( order = 10 ); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"ar\" , params = { \"order\" : 10 })","title":"Usage"},{"location":"user-guide/costs/costautoregressive/#reference","text":"[Bai2000] Bai, J. (2000). Vector autoregressive models with structural changes in regression coefficients and in variance\u2013covariance matrices. Annals of Economics and Finance, 1(2), 301\u2013336.","title":"Reference"},{"location":"user-guide/costs/costcustom/","text":"Custom cost class # Users who are interested in detecting a specific type of change can easily do so by creating a custom cost function. Provided, they subclass the base cost function [ BaseCost ][ruptures.base.BaseCost], they will be able to seamlessly run the algorithms implemented in ruptures . Important The custom cost class must at least implement the two following methods: .fit(signal) and .error(start, end) (see user guide ). Example # Let \\(\\{y_t\\}_t\\) denote a 1D piecewise stationary random process. Assume that the \\(y_t\\) are independent and exponentially distributed with a scale parameter that shifts at some unknown instants \\(t_1,t_2,\\dots\\) The change points estimates are the minimizers of the negative log-likelihood, and the associated cost function is given by \\[ c(y_I) = |I| \\log \\bar{\\mu}_I \\] where \\(I,\\, y_I\\) and \\(\\bar{\\mu}_I\\) are respectively an interval, the sub-signal on this interval and the empirical mean of this sub-signal. The following code implements this cost function: from math import log from ruptures.base import BaseCost class MyCost ( BaseCost ): \"\"\"Custom cost for exponential signals.\"\"\" # The 2 following attributes must be specified for compatibility. model = \"\" min_size = 2 def fit ( self , signal ): \"\"\"Set the internal parameter.\"\"\" self . signal = signal return self def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost \"\"\" sub = self . signal [ start : end ] return ( end - start ) * log ( sub . mean ()) Warning For compatibility reasons, the static attributes model and min_size must be explicitly specified: model is simply a string containing the name of the cost function (can be empty); min_size is a positive integer that indicates the minimum segment size (in number of samples) on which the cost function can be applied. This cost function can now be used with all algorithms from ruptures . For instance, import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data a = np . random . exponential ( scale = 1 , size = 100 ) b = np . random . exponential ( scale = 2 , size = 200 ) signal , bkps = np . r_ [ a , b , a ], [ 100 , 300 , 400 ] # cost algo = rpt . Pelt ( custom_cost = MyCost ()) . fit ( signal ) my_bkps = algo . predict ( pen = 10 ) # display rpt . display ( signal , bkps , my_bkps ) plt . show ()","title":"Custom cost"},{"location":"user-guide/costs/costcustom/#custom-cost-class","text":"Users who are interested in detecting a specific type of change can easily do so by creating a custom cost function. Provided, they subclass the base cost function [ BaseCost ][ruptures.base.BaseCost], they will be able to seamlessly run the algorithms implemented in ruptures . Important The custom cost class must at least implement the two following methods: .fit(signal) and .error(start, end) (see user guide ).","title":"Custom cost class"},{"location":"user-guide/costs/costcustom/#example","text":"Let \\(\\{y_t\\}_t\\) denote a 1D piecewise stationary random process. Assume that the \\(y_t\\) are independent and exponentially distributed with a scale parameter that shifts at some unknown instants \\(t_1,t_2,\\dots\\) The change points estimates are the minimizers of the negative log-likelihood, and the associated cost function is given by \\[ c(y_I) = |I| \\log \\bar{\\mu}_I \\] where \\(I,\\, y_I\\) and \\(\\bar{\\mu}_I\\) are respectively an interval, the sub-signal on this interval and the empirical mean of this sub-signal. The following code implements this cost function: from math import log from ruptures.base import BaseCost class MyCost ( BaseCost ): \"\"\"Custom cost for exponential signals.\"\"\" # The 2 following attributes must be specified for compatibility. model = \"\" min_size = 2 def fit ( self , signal ): \"\"\"Set the internal parameter.\"\"\" self . signal = signal return self def error ( self , start , end ): \"\"\"Return the approximation cost on the segment [start:end]. Args: start (int): start of the segment end (int): end of the segment Returns: float: segment cost \"\"\" sub = self . signal [ start : end ] return ( end - start ) * log ( sub . mean ()) Warning For compatibility reasons, the static attributes model and min_size must be explicitly specified: model is simply a string containing the name of the cost function (can be empty); min_size is a positive integer that indicates the minimum segment size (in number of samples) on which the cost function can be applied. This cost function can now be used with all algorithms from ruptures . For instance, import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data a = np . random . exponential ( scale = 1 , size = 100 ) b = np . random . exponential ( scale = 2 , size = 200 ) signal , bkps = np . r_ [ a , b , a ], [ 100 , 300 , 400 ] # cost algo = rpt . Pelt ( custom_cost = MyCost ()) . fit ( signal ) my_bkps = algo . predict ( pen = 10 ) # display rpt . display ( signal , bkps , my_bkps ) plt . show ()","title":"Example"},{"location":"user-guide/costs/costl1/","text":"Least absolute deviation ( CostL1 ) # Description # This cost function detects changes in the median of a signal. Overall, it is a robust estimator of a shift in the central point (mean, median, mode) of a distribution [Bai1995] . Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , \\[ c(y_{I}) = \\sum_{t\\in I} \\|y_t - \\bar{y}\\|_1 \\] where \\(\\bar{y}\\) is the componentwise median of \\(\\{y_t\\}_{t\\in I}\\) . Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostL1 ][ruptures.costs.costl1.CostL1] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostL1 () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator], either pass a [ CostL1 ][ruptures.costs.costl1.CostL1] instance (through the argument custom_cost ) or set model=\"l1\" . c = rpt . costs . CostL1 (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"l1\" ) References # [Bai1995] Bai, J. (1995). Least absolute deviation of a shift. Econometric Theory, 11(3), 403\u2013436.","title":"CostL1"},{"location":"user-guide/costs/costl1/#least-absolute-deviation-costl1","text":"","title":"Least absolute deviation (CostL1)"},{"location":"user-guide/costs/costl1/#description","text":"This cost function detects changes in the median of a signal. Overall, it is a robust estimator of a shift in the central point (mean, median, mode) of a distribution [Bai1995] . Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , \\[ c(y_{I}) = \\sum_{t\\in I} \\|y_t - \\bar{y}\\|_1 \\] where \\(\\bar{y}\\) is the componentwise median of \\(\\{y_t\\}_{t\\in I}\\) .","title":"Description"},{"location":"user-guide/costs/costl1/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostL1 ][ruptures.costs.costl1.CostL1] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostL1 () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator], either pass a [ CostL1 ][ruptures.costs.costl1.CostL1] instance (through the argument custom_cost ) or set model=\"l1\" . c = rpt . costs . CostL1 (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"l1\" )","title":"Usage"},{"location":"user-guide/costs/costl1/#references","text":"[Bai1995] Bai, J. (1995). Least absolute deviation of a shift. Econometric Theory, 11(3), 403\u2013436.","title":"References"},{"location":"user-guide/costs/costl2/","text":"Least squared deviation ( CostL2 ) # Description # This cost function detects mean-shifts in a signal. Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , \\[ c(y_{I}) = \\sum_{t\\in I} \\|y_t - \\bar{y}\\|_2^2 \\] where \\(\\bar{y}\\) is the mean of \\(\\{y_t\\}_{t\\in I}\\) . Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostL2 ][ruptures.costs.costl2.CostL2] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostL2 () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostL2 ][ruptures.costs.costl2.CostL2] instance (through the argument custom_cost ) or set model=\"l2\" . c = rpt . costs . CostL2 (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"l2\" )","title":"CostL2"},{"location":"user-guide/costs/costl2/#least-squared-deviation-costl2","text":"","title":"Least squared deviation (CostL2)"},{"location":"user-guide/costs/costl2/#description","text":"This cost function detects mean-shifts in a signal. Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , \\[ c(y_{I}) = \\sum_{t\\in I} \\|y_t - \\bar{y}\\|_2^2 \\] where \\(\\bar{y}\\) is the mean of \\(\\{y_t\\}_{t\\in I}\\) .","title":"Description"},{"location":"user-guide/costs/costl2/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostL2 ][ruptures.costs.costl2.CostL2] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostL2 () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostL2 ][ruptures.costs.costl2.CostL2] instance (through the argument custom_cost ) or set model=\"l2\" . c = rpt . costs . CostL2 (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"l2\" )","title":"Usage"},{"location":"user-guide/costs/costlinear/","text":"Linear model change ( CostLinear ) # Description # Let \\(0 < t_1 < t_2 < \\dots < n\\) be unknown change points indexes. Consider the following multiple linear regression model \\[ y_t = z_t' \\delta_j + \\varepsilon_t, \\quad \\forall t=t_j,\\dots,t_{j+1}-1 \\] for \\(j>1\\) . Here, the observed dependant variable is \\(y_t\\in\\mathbb{R}\\) , the covariate vector is \\(x_t \\in\\mathbb{R}^p\\) , the disturbance is \\(\\varepsilon_t\\in\\mathbb{R}\\) . The vectors \\(\\delta_j\\in\\mathbb{R}^p\\) are the parameter vectors (or regression coefficients). The least-squares estimates of the break dates is obtained by minimizing the sum of squared residuals [Bai2003] . Formally, the associated cost function on an interval \\(I\\) is \\[ c(y_{I}) = \\min_{\\delta\\in\\mathbb{R}^p} \\sum_{t\\in I} \\|y_t - \\delta' z_t \\|_2^2. \\] Usage # Start with the usual imports and create a signal with piecewise linear trends. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , n_reg = 2000 , 3 # number of samples, number of regressors (including intercept) n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation # regressors tt = np . linspace ( 0 , 10 * np . pi , n ) X = np . vstack (( np . sin ( tt ), np . sin ( 5 * tt ), np . ones ( n ))) . T # parameter vectors deltas , bkps = rpt . pw_constant ( n , n_reg , n_bkps , noise_std = None , delta = ( 1 , 3 )) # observed signal y = np . sum ( X * deltas , axis = 1 ) y += np . random . normal ( size = y . shape ) # display signal rpt . show . display ( y , bkps , figsize = ( 10 , 6 )) plt . show () Then create a [ CostLinear ][ruptures.costs.costlinear.CostLinear] instance and print the cost of the sub-signal signal[50:150] . # stack observed signal and regressors. # first dimension is the observed signal. signal = np . column_stack (( y . reshape ( - 1 , 1 ), X )) c = rpt . costs . CostLinear () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostLinear ][ruptures.costs.costlinear.CostLinear] instance (through the argument custom_cost ) or set model=\"linear\" . c = rpt . costs . CostLinear (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"linear\" ) References # [Bai2003] J. Bai and P. Perron. Critical values for multiple structural change tests. Econometrics Journal, 6(1):72\u201378, 2003.","title":"CostLinear"},{"location":"user-guide/costs/costlinear/#linear-model-change-costlinear","text":"","title":"Linear model change (CostLinear)"},{"location":"user-guide/costs/costlinear/#description","text":"Let \\(0 < t_1 < t_2 < \\dots < n\\) be unknown change points indexes. Consider the following multiple linear regression model \\[ y_t = z_t' \\delta_j + \\varepsilon_t, \\quad \\forall t=t_j,\\dots,t_{j+1}-1 \\] for \\(j>1\\) . Here, the observed dependant variable is \\(y_t\\in\\mathbb{R}\\) , the covariate vector is \\(x_t \\in\\mathbb{R}^p\\) , the disturbance is \\(\\varepsilon_t\\in\\mathbb{R}\\) . The vectors \\(\\delta_j\\in\\mathbb{R}^p\\) are the parameter vectors (or regression coefficients). The least-squares estimates of the break dates is obtained by minimizing the sum of squared residuals [Bai2003] . Formally, the associated cost function on an interval \\(I\\) is \\[ c(y_{I}) = \\min_{\\delta\\in\\mathbb{R}^p} \\sum_{t\\in I} \\|y_t - \\delta' z_t \\|_2^2. \\]","title":"Description"},{"location":"user-guide/costs/costlinear/#usage","text":"Start with the usual imports and create a signal with piecewise linear trends. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , n_reg = 2000 , 3 # number of samples, number of regressors (including intercept) n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation # regressors tt = np . linspace ( 0 , 10 * np . pi , n ) X = np . vstack (( np . sin ( tt ), np . sin ( 5 * tt ), np . ones ( n ))) . T # parameter vectors deltas , bkps = rpt . pw_constant ( n , n_reg , n_bkps , noise_std = None , delta = ( 1 , 3 )) # observed signal y = np . sum ( X * deltas , axis = 1 ) y += np . random . normal ( size = y . shape ) # display signal rpt . show . display ( y , bkps , figsize = ( 10 , 6 )) plt . show () Then create a [ CostLinear ][ruptures.costs.costlinear.CostLinear] instance and print the cost of the sub-signal signal[50:150] . # stack observed signal and regressors. # first dimension is the observed signal. signal = np . column_stack (( y . reshape ( - 1 , 1 ), X )) c = rpt . costs . CostLinear () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostLinear ][ruptures.costs.costlinear.CostLinear] instance (through the argument custom_cost ) or set model=\"linear\" . c = rpt . costs . CostLinear (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"linear\" )","title":"Usage"},{"location":"user-guide/costs/costlinear/#references","text":"[Bai2003] J. Bai and P. Perron. Critical values for multiple structural change tests. Econometrics Journal, 6(1):72\u201378, 2003.","title":"References"},{"location":"user-guide/costs/costml/","text":"Change detection with a Mahalanobis-type metric ( CostMl ) # Description # Given a positive semi-definite matrix \\(M\\in\\mathbb{R}^{d\\times d}\\) , this cost function detects changes in the mean of the embedded signal defined by the pseudo-metric \\[ \\| x - y \\|_M^2 = (x-y)^t M (x-y). \\] Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , the cost function is equal to \\[ c(y_{I}) = \\sum_{t\\in I} \\| y_t - \\bar{\\mu} \\|_{M}^2 \\] where \\(\\bar{\\mu}\\) is the empirical mean of the sub-signal \\(\\{y_t\\}_{t\\in I}\\) . The matrix \\(M\\) can for instance be the result of a similarity learning algorithm [ Xing2003 , Truong2019 ] or the inverse of the empirical covariance matrix (yielding the Mahalanobis distance). Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostMl ][ruptures.costs.costml.CostMl] instance and print the cost of the sub-signal signal[50:150] . M = np . eye ( dim ) c = rpt . costs . CostMl ( metric = M ) . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostMl ][ruptures.costs.costml.CostMl] instance (through the argument custom_cost ) or set model=\"mahalanobis\" . c = rpt . costs . CostMl ( metric = M ); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"mahalanobis\" , params = { \"metric\" : M }) References # [Xing2003] Xing, E. P., Jordan, M. I., & Russell, S. J. (2003). Distance metric learning, with application to clustering with side-Information. Advances in Neural Information Processing Systems (NIPS), 521\u2013528. [Truong2019] Truong, C., Oudre, L., & Vayatis, N. (2019). Supervised kernel change point detection with partial annotations. Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), 1\u20135.","title":"CostMl"},{"location":"user-guide/costs/costml/#change-detection-with-a-mahalanobis-type-metric-costml","text":"","title":"Change detection with a Mahalanobis-type metric (CostMl)"},{"location":"user-guide/costs/costml/#description","text":"Given a positive semi-definite matrix \\(M\\in\\mathbb{R}^{d\\times d}\\) , this cost function detects changes in the mean of the embedded signal defined by the pseudo-metric \\[ \\| x - y \\|_M^2 = (x-y)^t M (x-y). \\] Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , the cost function is equal to \\[ c(y_{I}) = \\sum_{t\\in I} \\| y_t - \\bar{\\mu} \\|_{M}^2 \\] where \\(\\bar{\\mu}\\) is the empirical mean of the sub-signal \\(\\{y_t\\}_{t\\in I}\\) . The matrix \\(M\\) can for instance be the result of a similarity learning algorithm [ Xing2003 , Truong2019 ] or the inverse of the empirical covariance matrix (yielding the Mahalanobis distance).","title":"Description"},{"location":"user-guide/costs/costml/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostMl ][ruptures.costs.costml.CostMl] instance and print the cost of the sub-signal signal[50:150] . M = np . eye ( dim ) c = rpt . costs . CostMl ( metric = M ) . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostMl ][ruptures.costs.costml.CostMl] instance (through the argument custom_cost ) or set model=\"mahalanobis\" . c = rpt . costs . CostMl ( metric = M ); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"mahalanobis\" , params = { \"metric\" : M })","title":"Usage"},{"location":"user-guide/costs/costml/#references","text":"[Xing2003] Xing, E. P., Jordan, M. I., & Russell, S. J. (2003). Distance metric learning, with application to clustering with side-Information. Advances in Neural Information Processing Systems (NIPS), 521\u2013528. [Truong2019] Truong, C., Oudre, L., & Vayatis, N. (2019). Supervised kernel change point detection with partial annotations. Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), 1\u20135.","title":"References"},{"location":"user-guide/costs/costnormal/","text":"Gaussian process change ( CostNormal ) # Description # This cost function detects changes in the mean and covariance matrix of a sequence of multivariate Gaussian random variables. Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , $$ c(y_{I}) = |I| \\log\\det\\widehat{\\Sigma}_I $$ where \\(\\widehat{\\Sigma}_I\\) is the empirical covariance matrix of the sub-signal \\(\\{y_t\\}_{t\\in I}\\) . It is robust to strongly dependant processes; for more information, see [Lavielle1999] (univariate case) and [Lavielle2006] (multivariate case). Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostNormal ][ruptures.costs.costnormal.CostNormal] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostNormal () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostNormal ][ruptures.costs.costnormal.CostNormal] instance (through the argument custom_cost ) or set model=\"normal\" . c = rpt . costs . CostNormal (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"normal\" ) References # [Lavielle1999] Lavielle, M. (1999). Detection of multiples changes in a sequence of dependant variables. Stochastic Processes and Their Applications, 83(1), 79\u2013102. [Lavielle2006] Lavielle, M., & Teyssi\u00e8re, G. (2006). Detection of multiple change-points in multivariate time series. Lithuanian Mathematical Journal, 46(3).","title":"CostNormal"},{"location":"user-guide/costs/costnormal/#gaussian-process-change-costnormal","text":"","title":"Gaussian process change (CostNormal)"},{"location":"user-guide/costs/costnormal/#description","text":"This cost function detects changes in the mean and covariance matrix of a sequence of multivariate Gaussian random variables. Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , $$ c(y_{I}) = |I| \\log\\det\\widehat{\\Sigma}_I $$ where \\(\\widehat{\\Sigma}_I\\) is the empirical covariance matrix of the sub-signal \\(\\{y_t\\}_{t\\in I}\\) . It is robust to strongly dependant processes; for more information, see [Lavielle1999] (univariate case) and [Lavielle2006] (multivariate case).","title":"Description"},{"location":"user-guide/costs/costnormal/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostNormal ][ruptures.costs.costnormal.CostNormal] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostNormal () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostNormal ][ruptures.costs.costnormal.CostNormal] instance (through the argument custom_cost ) or set model=\"normal\" . c = rpt . costs . CostNormal (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"normal\" )","title":"Usage"},{"location":"user-guide/costs/costnormal/#references","text":"[Lavielle1999] Lavielle, M. (1999). Detection of multiples changes in a sequence of dependant variables. Stochastic Processes and Their Applications, 83(1), 79\u2013102. [Lavielle2006] Lavielle, M., & Teyssi\u00e8re, G. (2006). Detection of multiple change-points in multivariate time series. Lithuanian Mathematical Journal, 46(3).","title":"References"},{"location":"user-guide/costs/costrank/","text":"Rank-based cost function ( CostRank ) # Description # This cost function detects general distribution changes in multivariate signals, using a rank transformation [Lung-Yut-Fong2015] . Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\([a, b)\\) , \\[ c_{rank}(a, b) = -(b - a) \\bar{r}_{a..b}' \\hat{\\Sigma}_r^{-1} \\bar{r}_{a..b} \\] where \\(\\bar{r}_{a..b}\\) is the empirical mean of the sub-signal \\(\\{r_t\\}_{t=a+1}^b\\) , and \\(\\hat{\\Sigma}_r\\) is the covariance matrix of the complete rank signal \\(r\\) . Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standard deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostRank ][ruptures.costs.costrank.CostRank] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostRank () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostRank ][ruptures.costs.costrank.CostRank] instance (through the argument custom_cost ) or set model=\"rank\" . c = rpt . costs . CostRank (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"rank\" ) References # [Lung-Yut-Fong2015] Lung-Yut-Fong, A., L\u00e9vy-Leduc, C., & Capp\u00e9, O. (2015). Homogeneity and change-point detection tests for multivariate data using rank statistics. Journal de La Soci\u00e9t\u00e9 Fran\u00e7aise de Statistique, 156(4), 133\u2013162.","title":"CostRank"},{"location":"user-guide/costs/costrank/#rank-based-cost-function-costrank","text":"","title":"Rank-based cost function (CostRank)"},{"location":"user-guide/costs/costrank/#description","text":"This cost function detects general distribution changes in multivariate signals, using a rank transformation [Lung-Yut-Fong2015] . Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\([a, b)\\) , \\[ c_{rank}(a, b) = -(b - a) \\bar{r}_{a..b}' \\hat{\\Sigma}_r^{-1} \\bar{r}_{a..b} \\] where \\(\\bar{r}_{a..b}\\) is the empirical mean of the sub-signal \\(\\{r_t\\}_{t=a+1}^b\\) , and \\(\\hat{\\Sigma}_r\\) is the covariance matrix of the complete rank signal \\(r\\) .","title":"Description"},{"location":"user-guide/costs/costrank/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standard deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostRank ][ruptures.costs.costrank.CostRank] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostRank () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostRank ][ruptures.costs.costrank.CostRank] instance (through the argument custom_cost ) or set model=\"rank\" . c = rpt . costs . CostRank (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"rank\" )","title":"Usage"},{"location":"user-guide/costs/costrank/#references","text":"[Lung-Yut-Fong2015] Lung-Yut-Fong, A., L\u00e9vy-Leduc, C., & Capp\u00e9, O. (2015). Homogeneity and change-point detection tests for multivariate data using rank statistics. Journal de La Soci\u00e9t\u00e9 Fran\u00e7aise de Statistique, 156(4), 133\u2013162.","title":"References"},{"location":"user-guide/costs/costrbf/","text":"Kernelized mean change ( CostRbf ) # Description # Given a positive semi-definite kernel \\(k(\\cdot, \\cdot) : \\mathbb{R}^d\\times \\mathbb{R}^d \\mapsto \\mathbb{R}\\) and its associated feature map \\(\\Phi:\\mathbb{R}^d \\mapsto \\mathcal{H}\\) (where \\(\\mathcal{H}\\) is an appropriate Hilbert space), this cost function detects changes in the mean of the embedded signal \\(\\{\\Phi(y_t)\\}_t\\) [ Garreau2018 , Arlot2019 ]. Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , \\[ c(y_{I}) = \\sum_{t\\in I} \\| \\Phi(y_t) - \\bar{\\mu} \\|_{\\mathcal{H}}^2 \\] where \\(\\bar{\\mu}\\) is the empirical mean of the embedded sub-signal \\(\\{\\Phi(y_t)\\}_{t\\in I}\\) . Here the kernel is the radial basis function (rbf): \\[ k(x, y) = \\exp(-\\gamma \\| x - y \\|^2 ) \\] where \\(\\| \\cdot \\|\\) is the Euclidean norm and \\(\\gamma>0\\) is the so-called bandwidth parameter and is determined according to median heuristics (i.e. equal to the inverse of median of all pairwise distances). In a nutshell, this cost function is able to detect changes in the distribution of an iid sequence of random variables. Because it is non-parametric, it is performs reasonably well on a wide range of tasks. Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostRbf ][ruptures.costs.costrbf.CostRbf] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostRbf () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostRbf ][ruptures.costs.costrbf.CostRbf] instance (through the argument custom_cost ) or set model=\"rbf\" . c = rpt . costs . CostRbf (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"rbf\" ) References # [Garreau2018] Garreau, D., & Arlot, S. (2018). Consistent change-point detection with kernels. Electronic Journal of Statistics, 12(2), 4440\u20134486. [Arlot2019] Arlot, S., Celisse, A., & Harchaoui, Z. (2019). A kernel multiple change-point algorithm via model selection. Journal of Machine Learning Research, 20(162), 1\u201356.","title":"CostRbf"},{"location":"user-guide/costs/costrbf/#kernelized-mean-change-costrbf","text":"","title":"Kernelized mean change (CostRbf)"},{"location":"user-guide/costs/costrbf/#description","text":"Given a positive semi-definite kernel \\(k(\\cdot, \\cdot) : \\mathbb{R}^d\\times \\mathbb{R}^d \\mapsto \\mathbb{R}\\) and its associated feature map \\(\\Phi:\\mathbb{R}^d \\mapsto \\mathcal{H}\\) (where \\(\\mathcal{H}\\) is an appropriate Hilbert space), this cost function detects changes in the mean of the embedded signal \\(\\{\\Phi(y_t)\\}_t\\) [ Garreau2018 , Arlot2019 ]. Formally, for a signal \\(\\{y_t\\}_t\\) on an interval \\(I\\) , \\[ c(y_{I}) = \\sum_{t\\in I} \\| \\Phi(y_t) - \\bar{\\mu} \\|_{\\mathcal{H}}^2 \\] where \\(\\bar{\\mu}\\) is the empirical mean of the embedded sub-signal \\(\\{\\Phi(y_t)\\}_{t\\in I}\\) . Here the kernel is the radial basis function (rbf): \\[ k(x, y) = \\exp(-\\gamma \\| x - y \\|^2 ) \\] where \\(\\| \\cdot \\|\\) is the Euclidean norm and \\(\\gamma>0\\) is the so-called bandwidth parameter and is determined according to median heuristics (i.e. equal to the inverse of median of all pairwise distances). In a nutshell, this cost function is able to detect changes in the distribution of an iid sequence of random variables. Because it is non-parametric, it is performs reasonably well on a wide range of tasks.","title":"Description"},{"location":"user-guide/costs/costrbf/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) Then create a [ CostRbf ][ruptures.costs.costrbf.CostRbf] instance and print the cost of the sub-signal signal[50:150] . c = rpt . costs . CostRbf () . fit ( signal ) print ( c . error ( 50 , 150 )) You can also compute the sum of costs for a given list of change points. print ( c . sum_of_costs ( bkps )) print ( c . sum_of_costs ([ 10 , 100 , 200 , 250 , n ])) In order to use this cost class in a change point detection algorithm (inheriting from [ BaseEstimator ][ruptures.base.BaseEstimator]), either pass a [ CostRbf ][ruptures.costs.costrbf.CostRbf] instance (through the argument custom_cost ) or set model=\"rbf\" . c = rpt . costs . CostRbf (); algo = rpt . Dynp ( custom_cost = c ) # is equivalent to algo = rpt . Dynp ( model = \"rbf\" )","title":"Usage"},{"location":"user-guide/costs/costrbf/#references","text":"[Garreau2018] Garreau, D., & Arlot, S. (2018). Consistent change-point detection with kernels. Electronic Journal of Statistics, 12(2), 4440\u20134486. [Arlot2019] Arlot, S., Celisse, A., & Harchaoui, Z. (2019). A kernel multiple change-point algorithm via model selection. Journal of Machine Learning Research, 20(162), 1\u201356.","title":"References"},{"location":"user-guide/datasets/pw_constant/","text":"Piecewise constant ( pw_constant ) # Description # For a given number of samples \\(T\\) , number \\(K\\) of change points and noise variance \\(\\sigma^2\\) , the function [ pw_constant ][ruptures.datasets.pw_constant.pw_constant] generates change point dexes \\(0 < t_1 < \\dots < t_K < T\\) and a piecewise constant signal \\(\\{y_t\\}_t\\) with additive Gaussian noise. Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standard deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps ) The mean shift amplitude is uniformly drawn from an interval that can be changed through the keyword delta . signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma , delta = ( 1 , 10 ))","title":"Piecewise constant"},{"location":"user-guide/datasets/pw_constant/#piecewise-constant-pw_constant","text":"","title":"Piecewise constant (pw_constant)"},{"location":"user-guide/datasets/pw_constant/#description","text":"For a given number of samples \\(T\\) , number \\(K\\) of change points and noise variance \\(\\sigma^2\\) , the function [ pw_constant ][ruptures.datasets.pw_constant.pw_constant] generates change point dexes \\(0 < t_1 < \\dots < t_K < T\\) and a piecewise constant signal \\(\\{y_t\\}_t\\) with additive Gaussian noise.","title":"Description"},{"location":"user-guide/datasets/pw_constant/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standard deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps ) The mean shift amplitude is uniformly drawn from an interval that can be changed through the keyword delta . signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma , delta = ( 1 , 10 ))","title":"Usage"},{"location":"user-guide/datasets/pw_linear/","text":"Piecewise linear ( pw_linear ) # Description # This function [ pw_linear ][ruptures.datasets.pw_linear.pw_linear] simulates a piecewise linear model (see Cost linear ). The covariates are standard Gaussian random variables. The response variable is a (piecewise) linear combination of the covariates. Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension of the covariates n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_linear ( n , dim , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps )","title":"Piecewise linear"},{"location":"user-guide/datasets/pw_linear/#piecewise-linear-pw_linear","text":"","title":"Piecewise linear (pw_linear)"},{"location":"user-guide/datasets/pw_linear/#description","text":"This function [ pw_linear ][ruptures.datasets.pw_linear.pw_linear] simulates a piecewise linear model (see Cost linear ). The covariates are standard Gaussian random variables. The response variable is a (piecewise) linear combination of the covariates.","title":"Description"},{"location":"user-guide/datasets/pw_linear/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension of the covariates n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_linear ( n , dim , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps )","title":"Usage"},{"location":"user-guide/datasets/pw_normal/","text":"Piecewise 2D Gaussian process ( pw_normal ) # Description # The function [ pw_normal ][ruptures.datasets.pw_normal.pw_normal] simulates a 2D signal of Gaussian i.i.d. random variables with zero mean and covariance matrix alternating between \\([[1, 0.9], [0.9, 1]]\\) and \\([[1, -0.9], [-0.9, 1]]\\) at every change point. Top and middle: 2D signal example. Bottom: Scatter plot for each regime type Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n = 500 , 3 # number of samples n_bkps = 3 # number of change points, noise standart deviation signal , bkps = rpt . pw_normal ( n , n_bkps ) rpt . display ( signal , bkps )","title":"Piecewise Gaussian"},{"location":"user-guide/datasets/pw_normal/#piecewise-2d-gaussian-process-pw_normal","text":"","title":"Piecewise 2D Gaussian process (pw_normal)"},{"location":"user-guide/datasets/pw_normal/#description","text":"The function [ pw_normal ][ruptures.datasets.pw_normal.pw_normal] simulates a 2D signal of Gaussian i.i.d. random variables with zero mean and covariance matrix alternating between \\([[1, 0.9], [0.9, 1]]\\) and \\([[1, -0.9], [-0.9, 1]]\\) at every change point. Top and middle: 2D signal example. Bottom: Scatter plot for each regime type","title":"Description"},{"location":"user-guide/datasets/pw_normal/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n = 500 , 3 # number of samples n_bkps = 3 # number of change points, noise standart deviation signal , bkps = rpt . pw_normal ( n , n_bkps ) rpt . display ( signal , bkps )","title":"Usage"},{"location":"user-guide/datasets/pw_wavy/","text":"Piecewise sinusoidal signal ( pw_wavy ) # Description # The function [ pw_wavy ][ruptures.datasets.pw_wavy.pw_wavy] simulates a sum-of-sine signal \\(y_t=\\sin(2\\pi f_1 t)+\\sin(2\\pi f_2 t)\\) where \\(t=0,\\dots,T-1\\) . The frequency vector \\([f_1, f_2]\\) alternates between \\([0.075, 0.1]\\) and \\([0.1, 0.125]\\) at each change point index. Gaussian white noise can be added to the signal. Top: signal example. Bottom: associated spectrogram. Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_wavy ( n , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps )","title":"Piecewise sinusoidal"},{"location":"user-guide/datasets/pw_wavy/#piecewise-sinusoidal-signal-pw_wavy","text":"","title":"Piecewise sinusoidal signal (pw_wavy)"},{"location":"user-guide/datasets/pw_wavy/#description","text":"The function [ pw_wavy ][ruptures.datasets.pw_wavy.pw_wavy] simulates a sum-of-sine signal \\(y_t=\\sin(2\\pi f_1 t)+\\sin(2\\pi f_2 t)\\) where \\(t=0,\\dots,T-1\\) . The frequency vector \\([f_1, f_2]\\) alternates between \\([0.075, 0.1]\\) and \\([0.1, 0.125]\\) at each change point index. Gaussian white noise can be added to the signal. Top: signal example. Bottom: associated spectrogram.","title":"Description"},{"location":"user-guide/datasets/pw_wavy/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_wavy ( n , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps )","title":"Usage"},{"location":"user-guide/detection/binseg/","text":"Binary segmentation ( Binseg ) # Description # Binary change point detection is used to perform fast signal segmentation and is implemented in [ Binseg ][ruptures.detection.binseg.Binseg]. It is a sequential approach: first, one change point is detected in the complete input signal, then series is split around this change point, then the operation is repeated on the two resulting sub-signals. For a theoretical and algorithmic analysis of [ Binseg ][ruptures.detection.binseg.Binseg], see for instance [Bai1997] and [Fryzlewicz2014] . The benefits of binary segmentation includes low complexity (of the order of \\(\\mathcal{O}(Cn\\log n)\\) , where \\(n\\) is the number of samples and \\(C\\) the complexity of calling the considered cost function on one sub-signal), the fact that it can extend any single change point detection method to detect multiple changes points and that it can work whether the number of regimes is known beforehand or not. Schematic view of the binary segmentation algorithm Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n = 500 # number of samples n_bkps , sigma = 3 , 5 # number of change points, noise standard deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) To perform a binary segmentation of a signal, initialize a [ BinSeg ][ruptures.detection.binseg.Binseg] instance. # change point detection model = \"l2\" # \"l1\", \"rbf\", \"linear\", \"normal\", \"ar\",... algo = rpt . Binseg ( model = model ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () In the situation in which the number of change points is unknown, one can specify a penalty using the pen parameter or a threshold on the residual norm using epsilon . my_bkps = algo . predict ( pen = np . log ( n ) * dim * sigma ** 2 ) # or my_bkps = algo . predict ( epsilon = 3 * n * sigma ** 2 ) For faster predictions, one can modify the jump parameter during initialization. The higher it is, the faster the prediction is achieved (at the expense of precision). algo = rpt . Binseg ( model = model , jump = 10 ) . fit ( signal ) References # [Bai1997] Bai, J. (1997). Estimating multiple breaks one at a time. Econometric Theory, 13(3), 315\u2013352. [Fryzlewicz2014] Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6), 2243\u20132281.","title":"Binary segmentation"},{"location":"user-guide/detection/binseg/#binary-segmentation-binseg","text":"","title":"Binary segmentation (Binseg)"},{"location":"user-guide/detection/binseg/#description","text":"Binary change point detection is used to perform fast signal segmentation and is implemented in [ Binseg ][ruptures.detection.binseg.Binseg]. It is a sequential approach: first, one change point is detected in the complete input signal, then series is split around this change point, then the operation is repeated on the two resulting sub-signals. For a theoretical and algorithmic analysis of [ Binseg ][ruptures.detection.binseg.Binseg], see for instance [Bai1997] and [Fryzlewicz2014] . The benefits of binary segmentation includes low complexity (of the order of \\(\\mathcal{O}(Cn\\log n)\\) , where \\(n\\) is the number of samples and \\(C\\) the complexity of calling the considered cost function on one sub-signal), the fact that it can extend any single change point detection method to detect multiple changes points and that it can work whether the number of regimes is known beforehand or not. Schematic view of the binary segmentation algorithm","title":"Description"},{"location":"user-guide/detection/binseg/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n = 500 # number of samples n_bkps , sigma = 3 , 5 # number of change points, noise standard deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) To perform a binary segmentation of a signal, initialize a [ BinSeg ][ruptures.detection.binseg.Binseg] instance. # change point detection model = \"l2\" # \"l1\", \"rbf\", \"linear\", \"normal\", \"ar\",... algo = rpt . Binseg ( model = model ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () In the situation in which the number of change points is unknown, one can specify a penalty using the pen parameter or a threshold on the residual norm using epsilon . my_bkps = algo . predict ( pen = np . log ( n ) * dim * sigma ** 2 ) # or my_bkps = algo . predict ( epsilon = 3 * n * sigma ** 2 ) For faster predictions, one can modify the jump parameter during initialization. The higher it is, the faster the prediction is achieved (at the expense of precision). algo = rpt . Binseg ( model = model , jump = 10 ) . fit ( signal )","title":"Usage"},{"location":"user-guide/detection/binseg/#references","text":"[Bai1997] Bai, J. (1997). Estimating multiple breaks one at a time. Econometric Theory, 13(3), 315\u2013352. [Fryzlewicz2014] Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6), 2243\u20132281.","title":"References"},{"location":"user-guide/detection/bottomup/","text":"Bottom-up segmentation ( BottomUp ) # Description # Bottom-up change point detection is used to perform fast signal segmentation and is implemented in [ BottomUp ][ruptures.detection.bottomup.BottomUp] in a sequential manner. Contrary to binary segmentation, which is a greedy procedure, bottom-up segmentation is generous: it starts with many change points and successively deletes the less significant ones. First, the signal is divided in many sub-signals along a regular grid. Then contiguous segments are successively merged according to a measure of how similar they are. See for instance [Keogh2001] or [Fryzlewicz2007] for an algorithmic analysis of [ BottomUp ][ruptures.detection.bottomup.BottomUp]. The benefits of bottom-up segmentation includes low complexity (of the order of \\(\\mathcal{O}(n\\log n)\\) , where \\(n\\) is the number of samples), the fact that it can extend any single change point detection method to detect multiple changes points and that it can work whether the number of regimes is known beforehand or not. Schematic view of the bottom-up segmentation algorithm Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) To perform a bottom-up segmentation of a signal, initialize a [ BottomUp ][ruptures.detection.bottomup.BottomUp] instance. # change point detection model = \"l2\" # \"l1\", \"rbf\", \"linear\", \"normal\", \"ar\" algo = rpt . BottomUp ( model = model ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () In the situation in which the number of change points is unknown, one can specify a penalty using the pen parameter or a threshold on the residual norm using epsilon . my_bkps = algo . predict ( pen = np . log ( n ) * dim * sigma ** 2 ) # or my_bkps = algo . predict ( epsilon = 3 * n * sigma ** 2 ) For faster predictions, one can modify the jump parameter during initialization. The higher it is, the faster the prediction is achieved (at the expense of precision). algo = rpt . BottomUp ( model = model , jump = 10 ) . fit ( signal ) References # [Keogh2001] Keogh, E., Chu, S., Hart, D., & Pazzani, M. (2001). An online algorithm for segmenting time series. Proceedings of the IEEE International Conference on Data Mining (ICDM), 289\u2013296. [Fryzlewicz2007] Fryzlewicz, P. (2007). Unbalanced Haar technique for nonparametric function estimation. Journal of the American Statistical Association, 102(480), 1318\u20131327.","title":"Bottom-up segmentation"},{"location":"user-guide/detection/bottomup/#bottom-up-segmentation-bottomup","text":"","title":"Bottom-up segmentation (BottomUp)"},{"location":"user-guide/detection/bottomup/#description","text":"Bottom-up change point detection is used to perform fast signal segmentation and is implemented in [ BottomUp ][ruptures.detection.bottomup.BottomUp] in a sequential manner. Contrary to binary segmentation, which is a greedy procedure, bottom-up segmentation is generous: it starts with many change points and successively deletes the less significant ones. First, the signal is divided in many sub-signals along a regular grid. Then contiguous segments are successively merged according to a measure of how similar they are. See for instance [Keogh2001] or [Fryzlewicz2007] for an algorithmic analysis of [ BottomUp ][ruptures.detection.bottomup.BottomUp]. The benefits of bottom-up segmentation includes low complexity (of the order of \\(\\mathcal{O}(n\\log n)\\) , where \\(n\\) is the number of samples), the fact that it can extend any single change point detection method to detect multiple changes points and that it can work whether the number of regimes is known beforehand or not. Schematic view of the bottom-up segmentation algorithm","title":"Description"},{"location":"user-guide/detection/bottomup/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) To perform a bottom-up segmentation of a signal, initialize a [ BottomUp ][ruptures.detection.bottomup.BottomUp] instance. # change point detection model = \"l2\" # \"l1\", \"rbf\", \"linear\", \"normal\", \"ar\" algo = rpt . BottomUp ( model = model ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () In the situation in which the number of change points is unknown, one can specify a penalty using the pen parameter or a threshold on the residual norm using epsilon . my_bkps = algo . predict ( pen = np . log ( n ) * dim * sigma ** 2 ) # or my_bkps = algo . predict ( epsilon = 3 * n * sigma ** 2 ) For faster predictions, one can modify the jump parameter during initialization. The higher it is, the faster the prediction is achieved (at the expense of precision). algo = rpt . BottomUp ( model = model , jump = 10 ) . fit ( signal )","title":"Usage"},{"location":"user-guide/detection/bottomup/#references","text":"[Keogh2001] Keogh, E., Chu, S., Hart, D., & Pazzani, M. (2001). An online algorithm for segmenting time series. Proceedings of the IEEE International Conference on Data Mining (ICDM), 289\u2013296. [Fryzlewicz2007] Fryzlewicz, P. (2007). Unbalanced Haar technique for nonparametric function estimation. Journal of the American Statistical Association, 102(480), 1318\u20131327.","title":"References"},{"location":"user-guide/detection/dynp/","text":"Dynamic programming ( Dynp ) # Description # The method is implemented in [ Dynp ][ruptures.detection.dynp.Dynp]. It finds the (exact) minimum of the sum of costs by computing the cost of all subsequences of a given signal. It is called \"dynamic programming\" because the search over all possible segmentations is ordered using a dynamic programming approach. In order to work, the user must specify in advance the number of changes to detect . (Consider using penalized methods when this number is unknown.) The complexity of the dynamic programming approach is of the order \\(\\mathcal{O}(CKn^2)\\) , where \\(K\\) is the number of change points to detect, \\(n\\) the number of samples and \\(C\\) the complexity of calling the considered cost function on one sub-signal. Consequently, piecewise constant models ( model=l2 ) are significantly faster than linear or autoregressive models. To reduce the computational cost, you can consider only a subsample of possible change point indexes, by changing the min_size and jump arguments when instantiating Dynp : min_size controls the minimum distance between change points; for instance, if min_size=10 , all change points will be at least 10 samples apart. jump controls the grid of possible change points; for instance, if jump=k , only changes at k, 2*k, 3*k,... are considered. Usage # import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 n_bkps , sigma = 3 , 5 signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) # change point detection model = \"l1\" # \"l2\", \"rbf\" algo = rpt . Dynp ( model = model , min_size = 3 , jump = 5 ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show ()","title":"Dynamic programming"},{"location":"user-guide/detection/dynp/#dynamic-programming-dynp","text":"","title":"Dynamic programming (Dynp)"},{"location":"user-guide/detection/dynp/#description","text":"The method is implemented in [ Dynp ][ruptures.detection.dynp.Dynp]. It finds the (exact) minimum of the sum of costs by computing the cost of all subsequences of a given signal. It is called \"dynamic programming\" because the search over all possible segmentations is ordered using a dynamic programming approach. In order to work, the user must specify in advance the number of changes to detect . (Consider using penalized methods when this number is unknown.) The complexity of the dynamic programming approach is of the order \\(\\mathcal{O}(CKn^2)\\) , where \\(K\\) is the number of change points to detect, \\(n\\) the number of samples and \\(C\\) the complexity of calling the considered cost function on one sub-signal. Consequently, piecewise constant models ( model=l2 ) are significantly faster than linear or autoregressive models. To reduce the computational cost, you can consider only a subsample of possible change point indexes, by changing the min_size and jump arguments when instantiating Dynp : min_size controls the minimum distance between change points; for instance, if min_size=10 , all change points will be at least 10 samples apart. jump controls the grid of possible change points; for instance, if jump=k , only changes at k, 2*k, 3*k,... are considered.","title":"Description"},{"location":"user-guide/detection/dynp/#usage","text":"import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 n_bkps , sigma = 3 , 5 signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) # change point detection model = \"l1\" # \"l2\", \"rbf\" algo = rpt . Dynp ( model = model , min_size = 3 , jump = 5 ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show ()","title":"Usage"},{"location":"user-guide/detection/pelt/","text":"Linearly penalized segmentation ( Pelt ) # Description # The method is implemented in [ Pelt ][ruptures.detection.pelt.Pelt]. Because the enumeration of all possible partitions impossible, the algorithm relies on a pruning rule. Many indexes are discarded, greatly reducing the computational cost while retaining the ability to find the optimal segmentation. The implementation follows [Killick2012] . In addition, under certain conditions on the change point repartition, the avarage computational complexity is of the order of \\(\\mathcal{O}(CKn)\\) , where \\(K\\) is the number of change points to detect, \\(n\\) the number of samples and \\(C\\) the complexity of calling the considered cost function on one sub-signal. Consequently, piecewise constant models ( model=l2 ) are significantly faster than linear or autoregressive models. To reduce the computational cost, you can consider only a subsample of possible change point indexes, by changing the min_size and jump arguments when instantiating Pelt : min_size controls the minimum distance between change points; for instance, if min_size=10 , all change points will be at least 10 samples apart. jump controls the grid of possible change points; for instance, if jump=k , only changes at k, 2*k, 3*k,... are considered. Usage # import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 n_bkps , sigma = 3 , 1 signal , b = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) # change point detection model = \"l1\" # \"l2\", \"rbf\" algo = rpt . Pelt ( model = model , min_size = 3 , jump = 5 ) . fit ( signal ) my_bkps = algo . predict ( pen = 3 ) # show results fig , ( ax ,) = rpt . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () References # [Killick2012] Killick, R., Fearnhead, P., & Eckley, I. (2012). Optimal detection of changepoints with a linear computational cost. Journal of the American Statistical Association, 107(500), 1590\u20131598.","title":"Pelt"},{"location":"user-guide/detection/pelt/#linearly-penalized-segmentation-pelt","text":"","title":"Linearly penalized segmentation (Pelt)"},{"location":"user-guide/detection/pelt/#description","text":"The method is implemented in [ Pelt ][ruptures.detection.pelt.Pelt]. Because the enumeration of all possible partitions impossible, the algorithm relies on a pruning rule. Many indexes are discarded, greatly reducing the computational cost while retaining the ability to find the optimal segmentation. The implementation follows [Killick2012] . In addition, under certain conditions on the change point repartition, the avarage computational complexity is of the order of \\(\\mathcal{O}(CKn)\\) , where \\(K\\) is the number of change points to detect, \\(n\\) the number of samples and \\(C\\) the complexity of calling the considered cost function on one sub-signal. Consequently, piecewise constant models ( model=l2 ) are significantly faster than linear or autoregressive models. To reduce the computational cost, you can consider only a subsample of possible change point indexes, by changing the min_size and jump arguments when instantiating Pelt : min_size controls the minimum distance between change points; for instance, if min_size=10 , all change points will be at least 10 samples apart. jump controls the grid of possible change points; for instance, if jump=k , only changes at k, 2*k, 3*k,... are considered.","title":"Description"},{"location":"user-guide/detection/pelt/#usage","text":"import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 n_bkps , sigma = 3 , 1 signal , b = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) # change point detection model = \"l1\" # \"l2\", \"rbf\" algo = rpt . Pelt ( model = model , min_size = 3 , jump = 5 ) . fit ( signal ) my_bkps = algo . predict ( pen = 3 ) # show results fig , ( ax ,) = rpt . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show ()","title":"Usage"},{"location":"user-guide/detection/pelt/#references","text":"[Killick2012] Killick, R., Fearnhead, P., & Eckley, I. (2012). Optimal detection of changepoints with a linear computational cost. Journal of the American Statistical Association, 107(500), 1590\u20131598.","title":"References"},{"location":"user-guide/detection/window/","text":"Window-based change point detection ( Window ) # Description # Window-based change point detection is used to perform fast signal segmentation and is implemented in [ Window ][ruptures.detection.window.Window]. The algorithm uses two windows which slide along the data stream. The statistical properties of the signals within each window are compared with a discrepancy measure. For a given cost function \\(c(\\cdot)\\) , a discrepancy measure is derived \\(d(\\cdot,\\cdot)\\) as follows: \\[ d(y_{u..v}, y_{v..w}) = c(y_{u..w}) - c(y_{u..v}) - c(y_{v..w}) \\] where \\(\\{y_t\\}_t\\) is the input signal and \\(u < v < w\\) are indexes. The discrepancy is the cost gain of splitting the sub-signal \\(y_{u..w}\\) at the index \\(v\\) . If the sliding windows \\(u..v\\) and \\(v..w\\) both fall into a segment, their statistical properties are similar and the discrepancy between the first window and the second window is low. If the sliding windows fall into two dissimilar segments, the discrepancy is significantly higher, suggesting that the boundary between windows is a change point. The discrepancy curve is the curve, defined for all indexes \\(t\\) between \\(w/2\\) and \\(n-w/2\\) ( \\(n\\) is the number of samples), \\[ \\big(t, d(y_{t-w/2..t}, y_{t..t+w/2})\\big) \\] where \\(w\\) is the window length. A sequential peak search is performed on the discrepancy curve in order to detect change points. The benefits of window-based segmentation includes low complexity (of the order of \\(\\mathcal{O}(n w)\\) , where \\(n\\) is the number of samples), the fact that it can extend any single change point detection method to detect multiple changes points and that it can work whether the number of regimes is known beforehand or not. Schematic view of the window sliding segmentation algorithm Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) To perform a binary segmentation of a signal, initialize a [ Window ][ruptures.detection.window.Window] instance. # change point detection model = \"l2\" # \"l1\", \"rbf\", \"linear\", \"normal\", \"ar\" algo = rpt . Window ( width = 40 , model = model ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () The window length (in number of samples) is modified through the argument width . Usual methods assume that the window length is smaller than the smallest regime length. In the situation in which the number of change points is unknown, one can specify a penalty using the pen parameter or a threshold on the residual norm using epsilon . my_bkps = algo . predict ( pen = np . log ( n ) * dim * sigma ** 2 ) # or my_bkps = algo . predict ( epsilon = 3 * n * sigma ** 2 ) For faster predictions, one can modify the jump parameter during initialization. The higher it is, the faster the prediction is achieved (at the expense of precision). algo = rpt . Window ( model = model , jump = 10 ) . fit ( signal )","title":"Window sliding segmentation"},{"location":"user-guide/detection/window/#window-based-change-point-detection-window","text":"","title":"Window-based change point detection (Window)"},{"location":"user-guide/detection/window/#description","text":"Window-based change point detection is used to perform fast signal segmentation and is implemented in [ Window ][ruptures.detection.window.Window]. The algorithm uses two windows which slide along the data stream. The statistical properties of the signals within each window are compared with a discrepancy measure. For a given cost function \\(c(\\cdot)\\) , a discrepancy measure is derived \\(d(\\cdot,\\cdot)\\) as follows: \\[ d(y_{u..v}, y_{v..w}) = c(y_{u..w}) - c(y_{u..v}) - c(y_{v..w}) \\] where \\(\\{y_t\\}_t\\) is the input signal and \\(u < v < w\\) are indexes. The discrepancy is the cost gain of splitting the sub-signal \\(y_{u..w}\\) at the index \\(v\\) . If the sliding windows \\(u..v\\) and \\(v..w\\) both fall into a segment, their statistical properties are similar and the discrepancy between the first window and the second window is low. If the sliding windows fall into two dissimilar segments, the discrepancy is significantly higher, suggesting that the boundary between windows is a change point. The discrepancy curve is the curve, defined for all indexes \\(t\\) between \\(w/2\\) and \\(n-w/2\\) ( \\(n\\) is the number of samples), \\[ \\big(t, d(y_{t-w/2..t}, y_{t..t+w/2})\\big) \\] where \\(w\\) is the window length. A sequential peak search is performed on the discrepancy curve in order to detect change points. The benefits of window-based segmentation includes low complexity (of the order of \\(\\mathcal{O}(n w)\\) , where \\(n\\) is the number of samples), the fact that it can extend any single change point detection method to detect multiple changes points and that it can work whether the number of regimes is known beforehand or not. Schematic view of the window sliding segmentation algorithm","title":"Description"},{"location":"user-guide/detection/window/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 3 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) To perform a binary segmentation of a signal, initialize a [ Window ][ruptures.detection.window.Window] instance. # change point detection model = \"l2\" # \"l1\", \"rbf\", \"linear\", \"normal\", \"ar\" algo = rpt . Window ( width = 40 , model = model ) . fit ( signal ) my_bkps = algo . predict ( n_bkps = 3 ) # show results rpt . show . display ( signal , bkps , my_bkps , figsize = ( 10 , 6 )) plt . show () The window length (in number of samples) is modified through the argument width . Usual methods assume that the window length is smaller than the smallest regime length. In the situation in which the number of change points is unknown, one can specify a penalty using the pen parameter or a threshold on the residual norm using epsilon . my_bkps = algo . predict ( pen = np . log ( n ) * dim * sigma ** 2 ) # or my_bkps = algo . predict ( epsilon = 3 * n * sigma ** 2 ) For faster predictions, one can modify the jump parameter during initialization. The higher it is, the faster the prediction is achieved (at the expense of precision). algo = rpt . Window ( model = model , jump = 10 ) . fit ( signal )","title":"Usage"},{"location":"user-guide/metrics/hausdorff/","text":"Hausdorff metric ( hausdorff ) # Description # The [ hausdorff ][ruptures.metrics.hausdorff.hausdorff] function computes the Hausdorff metric which measures the worst prediction error. Assume a set of change point indexes \\(t_1,t_2,\\dots\\) and their estimates \\(\\hat{t}_1, \\hat{t}_2,\\dots\\) . The Hausdorff metric is then equal to \\[ \\text{Hausdorff}(\\{t_k\\}_k, \\{\\hat{t}_k\\}_k) := \\max \\{ \\max_k \\min_l |t_k - \\hat{t}_l| \\, , \\max_k \\min_l |\\hat{t}_k - t_l|\\}. \\] Schematic example: true segmentation in gray, estimated segmentation in dashed lines. Here, Hausdorff is equal to \\(\\max(\\Delta t_1, \\Delta t_2, \\Delta t_3)\\) . Usage # Start with the usual imports and create two segmentations to compare. from ruptures.metrics import hausdorff bkps1 , bkps2 = [ 100 , 200 , 500 ], [ 105 , 115 , 350 , 400 , 500 ] print ( hausdorff ( bkps1 , bkps2 ))","title":"Hausdorff metric"},{"location":"user-guide/metrics/hausdorff/#hausdorff-metric-hausdorff","text":"","title":"Hausdorff metric (hausdorff)"},{"location":"user-guide/metrics/hausdorff/#description","text":"The [ hausdorff ][ruptures.metrics.hausdorff.hausdorff] function computes the Hausdorff metric which measures the worst prediction error. Assume a set of change point indexes \\(t_1,t_2,\\dots\\) and their estimates \\(\\hat{t}_1, \\hat{t}_2,\\dots\\) . The Hausdorff metric is then equal to \\[ \\text{Hausdorff}(\\{t_k\\}_k, \\{\\hat{t}_k\\}_k) := \\max \\{ \\max_k \\min_l |t_k - \\hat{t}_l| \\, , \\max_k \\min_l |\\hat{t}_k - t_l|\\}. \\] Schematic example: true segmentation in gray, estimated segmentation in dashed lines. Here, Hausdorff is equal to \\(\\max(\\Delta t_1, \\Delta t_2, \\Delta t_3)\\) .","title":"Description"},{"location":"user-guide/metrics/hausdorff/#usage","text":"Start with the usual imports and create two segmentations to compare. from ruptures.metrics import hausdorff bkps1 , bkps2 = [ 100 , 200 , 500 ], [ 105 , 115 , 350 , 400 , 500 ] print ( hausdorff ( bkps1 , bkps2 ))","title":"Usage"},{"location":"user-guide/metrics/precisionrecall/","text":"Precision and recall ( precision_recall ) # Description # The precision and recall of an estimated segmentation is computed by the function [ precision_recall ][ruptures.metrics.precisionrecall.precision_recall] as follows. A true change point is declared \"detected\" (or positive) if there is at least one computed change point at less than \"margin\" points from it. Formally, assume a set of change point indexes \\(t_1,t_2,\\dots\\) and their estimates \\(\\hat{t}_1, \\hat{t}_2,\\dots\\) In the context of change point detection, precision and recall are defined as follows: \\[ \\text{precision}:=|\\text{TP}|/|\\{\\hat{t}_l\\}_l| \\quad \\text{and}\\quad\\text{recall}:=|\\text{TP}|/|\\{t_k\\}_k| \\] where, for a given margin \\(M\\) , true positives \\(\\text{TP}\\) are true change points for which there is an estimated one at less than \\(M\\) samples, i.e. \\[ \\text{TP}:= \\{t_k\\,|\\, \\exists\\, \\hat{t}_l\\,\\, \\text{s.t.}\\, |\\hat{t}_l - t_k|<M \\}. \\] Schematic example: true segmentation in gray, estimated segmentation in dashed lines and margin in dashed areas. Here, precision is 2/3 and recall is 2/2. Usage # Start with the usual imports and create two change point sets to compare. from ruptures.metrics import precision_recall bkps1 , bkps2 = [ 100 , 200 , 500 ], [ 105 , 115 , 350 , 400 , 500 ] p , r = precision_recall ( bkps1 , bkps2 ) print (( p , r )) The margin parameter \\(M\\) can be changed through the keyword margin (default is 10 samples). p , r = precision_recall ( bkps1 , bkps2 , margin = 10 ) print (( p , r )) p , r = precision_recall ( bkps1 , bkps2 , margin = 20 ) print (( p , r ))","title":"Precision and recall"},{"location":"user-guide/metrics/precisionrecall/#precision-and-recall-precision_recall","text":"","title":"Precision and recall (precision_recall)"},{"location":"user-guide/metrics/precisionrecall/#description","text":"The precision and recall of an estimated segmentation is computed by the function [ precision_recall ][ruptures.metrics.precisionrecall.precision_recall] as follows. A true change point is declared \"detected\" (or positive) if there is at least one computed change point at less than \"margin\" points from it. Formally, assume a set of change point indexes \\(t_1,t_2,\\dots\\) and their estimates \\(\\hat{t}_1, \\hat{t}_2,\\dots\\) In the context of change point detection, precision and recall are defined as follows: \\[ \\text{precision}:=|\\text{TP}|/|\\{\\hat{t}_l\\}_l| \\quad \\text{and}\\quad\\text{recall}:=|\\text{TP}|/|\\{t_k\\}_k| \\] where, for a given margin \\(M\\) , true positives \\(\\text{TP}\\) are true change points for which there is an estimated one at less than \\(M\\) samples, i.e. \\[ \\text{TP}:= \\{t_k\\,|\\, \\exists\\, \\hat{t}_l\\,\\, \\text{s.t.}\\, |\\hat{t}_l - t_k|<M \\}. \\] Schematic example: true segmentation in gray, estimated segmentation in dashed lines and margin in dashed areas. Here, precision is 2/3 and recall is 2/2.","title":"Description"},{"location":"user-guide/metrics/precisionrecall/#usage","text":"Start with the usual imports and create two change point sets to compare. from ruptures.metrics import precision_recall bkps1 , bkps2 = [ 100 , 200 , 500 ], [ 105 , 115 , 350 , 400 , 500 ] p , r = precision_recall ( bkps1 , bkps2 ) print (( p , r )) The margin parameter \\(M\\) can be changed through the keyword margin (default is 10 samples). p , r = precision_recall ( bkps1 , bkps2 , margin = 10 ) print (( p , r )) p , r = precision_recall ( bkps1 , bkps2 , margin = 20 ) print (( p , r ))","title":"Usage"},{"location":"user-guide/metrics/randindex/","text":"Rand index ( randindex ) # Description # The Rand index, computed by the [ randindex ][ruptures.metrics.randindex.randindex] function, measures the similarity between two segmentations. Formally, for a signal \\(\\{y_t\\}_t\\) and a segmentation \\(\\mathcal{S}\\) , denote by \\(A\\) the associated membership matrix: \\[ \\begin{aligned} \\mathcal{A}_{ij} &= 1 \\text{ if both samples } y_i \\text{ and } y_j \\text{ are in the same segment according to } \\mathcal{S} \\\\ &= 0 \\quad\\text{otherwise} \\end{aligned} \\] Let \\(\\hat{\\mathcal{S}}\\) be the estimated segmentation and \\(\\hat{A}\\) , the associated membership matrix. Then the Rand index is equal to \\[ \\frac{\\sum_{i<j} \\mathbb{1}(A_{ij} = \\hat{A}_{ij})}{T(T-1)/2} \\] where \\(T\\) is the number of samples. It has a value between 0 and 1: 0 indicates that the two segmentations do not agree on any pair of points and 1 indicates that the two segmentations are exactly the same. Schematic example: true segmentation in gray, estimated segmentation in dashed lines and their associated membership matrices. Rand index is equal to 1 minus the gray area. Usage # Start with the usual imports and create two segmentations to compare. from ruptures.metrics import randindex bkps1 , bkps2 = [ 100 , 200 , 500 ], [ 105 , 115 , 350 , 400 , 500 ] print ( randindex ( bkps1 , bkps2 ))","title":"Rand index"},{"location":"user-guide/metrics/randindex/#rand-index-randindex","text":"","title":"Rand index (randindex)"},{"location":"user-guide/metrics/randindex/#description","text":"The Rand index, computed by the [ randindex ][ruptures.metrics.randindex.randindex] function, measures the similarity between two segmentations. Formally, for a signal \\(\\{y_t\\}_t\\) and a segmentation \\(\\mathcal{S}\\) , denote by \\(A\\) the associated membership matrix: \\[ \\begin{aligned} \\mathcal{A}_{ij} &= 1 \\text{ if both samples } y_i \\text{ and } y_j \\text{ are in the same segment according to } \\mathcal{S} \\\\ &= 0 \\quad\\text{otherwise} \\end{aligned} \\] Let \\(\\hat{\\mathcal{S}}\\) be the estimated segmentation and \\(\\hat{A}\\) , the associated membership matrix. Then the Rand index is equal to \\[ \\frac{\\sum_{i<j} \\mathbb{1}(A_{ij} = \\hat{A}_{ij})}{T(T-1)/2} \\] where \\(T\\) is the number of samples. It has a value between 0 and 1: 0 indicates that the two segmentations do not agree on any pair of points and 1 indicates that the two segmentations are exactly the same. Schematic example: true segmentation in gray, estimated segmentation in dashed lines and their associated membership matrices. Rand index is equal to 1 minus the gray area.","title":"Description"},{"location":"user-guide/metrics/randindex/#usage","text":"Start with the usual imports and create two segmentations to compare. from ruptures.metrics import randindex bkps1 , bkps2 = [ 100 , 200 , 500 ], [ 105 , 115 , 350 , 400 , 500 ] print ( randindex ( bkps1 , bkps2 ))","title":"Usage"},{"location":"user-guide/show/display/","text":"Display ( display ) # Description # The function [ display ][ruptures.show.display.display] displays a signal and the change points provided in alternating colors. If another set of change point indexes is provided, they are displayed with dashed vertical dashed lines. Usage # Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 2 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps ) If we computed another set of change points, for instance [110, 150, 320, 500] , we can easily compare the two segmentations. rpt . display ( signal , bkps , [ 110 , 150 , 320 , 500 ]) Example output of the function [ display ][ruptures.show.display.display].","title":"Display"},{"location":"user-guide/show/display/#display-display","text":"","title":"Display (display)"},{"location":"user-guide/show/display/#description","text":"The function [ display ][ruptures.show.display.display] displays a signal and the change points provided in alternating colors. If another set of change point indexes is provided, they are displayed with dashed vertical dashed lines.","title":"Description"},{"location":"user-guide/show/display/#usage","text":"Start with the usual imports and create a signal. import numpy as np import matplotlib.pylab as plt import ruptures as rpt # creation of data n , dim = 500 , 2 # number of samples, dimension n_bkps , sigma = 3 , 5 # number of change points, noise standart deviation signal , bkps = rpt . pw_constant ( n , dim , n_bkps , noise_std = sigma ) rpt . display ( signal , bkps ) If we computed another set of change points, for instance [110, 150, 320, 500] , we can easily compare the two segmentations. rpt . display ( signal , bkps , [ 110 , 150 , 320 , 500 ]) Example output of the function [ display ][ruptures.show.display.display].","title":"Usage"},{"location":"notebooks/basic-usage/","text":"Basic usage # Let us start with a simple example to illustrate the use of ruptures : generate a 3-dimensional piecewise constant signal with noise and estimate the change points. Setup # First, we make the necessary imports. import matplotlib.pyplot as plt # for display purposes import ruptures as rpt # our package Generate and display the signal # Let us generate a 3-dimensional piecewise constant signal with Gaussian noise. n_samples , n_dims , sigma = 1000 , 3 , 2 n_bkps = 4 # number of breakpoints signal , bkps = rpt . pw_constant ( n_samples , n_dims , n_bkps , noise_std = sigma ) The true change points of this synthetic signal are available in the bkps variable. print ( bkps ) [204, 404, 615, 809, 1000] Note that the first four element are change point indexes while the last is simply the number of samples. (This is a technical convention so that functions in ruptures always know the length of the signal at hand.) It is also possible to plot our \\(\\mathbb{R}^3\\) -valued signal along with the true change points with the rpt.display function. In the following image, the color changes whenever the mean of the signal shifts. fig , ax_array = rpt . display ( signal , bkps ) Change point detection # We can now perform change point detection, meaning that we find the indexes where the signal mean changes. To that end, we minimize the sum of squared errors when approximating the signal by a piecewise constant signal. Formally, for a signal \\(y_0,y_1,\\dots,y_{T-1}\\) ( \\(T\\) samples), we solve the following optimization problem, over all possible change positions \\(t_1<t_2<\\dots<t_K\\) (where the number \\(K\\) of changes is defined by the user): \\[ \\hat{t}_1, \\hat{t}_2,\\dots,\\hat{t}_K = \\arg\\min_{t_1,\\dots,t_K} V(t_1,t_2,\\dots,t_K) \\] with \\[ V(t_1,t_2,\\dots,t_K) := \\sum_{k=0}^K\\sum_{t=t_k}^{t_{k+1}-1} \\|y_t-\\bar{y}_{t_k..t_{k+1}}\\|^2 \\] where \\(\\bar{y}_{t_k..t_{k+1}}\\) is the empirical mean of the sub-signal \\(y_{t_k}, y_{t_k+1},\\dots,y_{t_{k+1}-1}\\) . (By convention \\(t_0=0\\) and \\(t_{K+1}=T\\) .) This optimization is solved with dynamic programming, using the Dynp class. (More information in the section What is change point detection? and the User guide .) # detection algo = rpt . Dynp ( model = \"l2\" ) . fit ( signal ) result = algo . predict ( n_bkps = 4 ) print ( result ) [205, 405, 615, 810, 1000] Display the results # Again the first elements are change point indexes and the last is the number of samples. To visualy compare the true segmentation ( bkps ) and the estimated one ( result ), we can resort to rpt.display a second time. In the following image, the alternating colors indicate the true breakpoints and the dashed vertical lines, the estimated breakpoints. # display rpt . display ( signal , bkps , result ) plt . show () In this simple example, both are quite similar and almost undistinguishable.","title":"Basic usage"},{"location":"notebooks/basic-usage/#basic-usage","text":"Let us start with a simple example to illustrate the use of ruptures : generate a 3-dimensional piecewise constant signal with noise and estimate the change points.","title":"Basic usage"},{"location":"notebooks/basic-usage/#setup","text":"First, we make the necessary imports. import matplotlib.pyplot as plt # for display purposes import ruptures as rpt # our package","title":"Setup"},{"location":"notebooks/basic-usage/#generate-and-display-the-signal","text":"Let us generate a 3-dimensional piecewise constant signal with Gaussian noise. n_samples , n_dims , sigma = 1000 , 3 , 2 n_bkps = 4 # number of breakpoints signal , bkps = rpt . pw_constant ( n_samples , n_dims , n_bkps , noise_std = sigma ) The true change points of this synthetic signal are available in the bkps variable. print ( bkps ) [204, 404, 615, 809, 1000] Note that the first four element are change point indexes while the last is simply the number of samples. (This is a technical convention so that functions in ruptures always know the length of the signal at hand.) It is also possible to plot our \\(\\mathbb{R}^3\\) -valued signal along with the true change points with the rpt.display function. In the following image, the color changes whenever the mean of the signal shifts. fig , ax_array = rpt . display ( signal , bkps )","title":"Generate and display the signal"},{"location":"notebooks/basic-usage/#change-point-detection","text":"We can now perform change point detection, meaning that we find the indexes where the signal mean changes. To that end, we minimize the sum of squared errors when approximating the signal by a piecewise constant signal. Formally, for a signal \\(y_0,y_1,\\dots,y_{T-1}\\) ( \\(T\\) samples), we solve the following optimization problem, over all possible change positions \\(t_1<t_2<\\dots<t_K\\) (where the number \\(K\\) of changes is defined by the user): \\[ \\hat{t}_1, \\hat{t}_2,\\dots,\\hat{t}_K = \\arg\\min_{t_1,\\dots,t_K} V(t_1,t_2,\\dots,t_K) \\] with \\[ V(t_1,t_2,\\dots,t_K) := \\sum_{k=0}^K\\sum_{t=t_k}^{t_{k+1}-1} \\|y_t-\\bar{y}_{t_k..t_{k+1}}\\|^2 \\] where \\(\\bar{y}_{t_k..t_{k+1}}\\) is the empirical mean of the sub-signal \\(y_{t_k}, y_{t_k+1},\\dots,y_{t_{k+1}-1}\\) . (By convention \\(t_0=0\\) and \\(t_{K+1}=T\\) .) This optimization is solved with dynamic programming, using the Dynp class. (More information in the section What is change point detection? and the User guide .) # detection algo = rpt . Dynp ( model = \"l2\" ) . fit ( signal ) result = algo . predict ( n_bkps = 4 ) print ( result ) [205, 405, 615, 810, 1000]","title":"Change point detection"},{"location":"notebooks/basic-usage/#display-the-results","text":"Again the first elements are change point indexes and the last is the number of samples. To visualy compare the true segmentation ( bkps ) and the estimated one ( result ), we can resort to rpt.display a second time. In the following image, the alternating colors indicate the true breakpoints and the dashed vertical lines, the estimated breakpoints. # display rpt . display ( signal , bkps , result ) plt . show () In this simple example, both are quite similar and almost undistinguishable.","title":"Display the results"},{"location":"notebooks/simple-example/","text":"Basic usage # Let's start with a simple example to illustrate the use of ruptures. First, we make the necessary imports and generate a piecewise constant signal with noise. import matplotlib.pyplot as plt # for display purposes import ruptures as rpt # our package # generate signal n_samples , dim , sigma = 1000 , 3 , 2 n_bkps = 4 # number of breakpoints signal , bkps = rpt . pw_constant ( n_samples , dim , n_bkps , noise_std = sigma ) The true change points of this synthetic signal are available in the bkps variable. print ( bkps ) [199, 390, 592, 797, 1000] Note that the first four element are change point indexes while the last is simply the number of samples. (This is a technical convention so that functions in ruptures always know the length of the signal at hand.) It is also possible to plot our \\(\\mathbb{R}^3\\) -valued signal along with the true change points with the rpt.display function. In the following image, the color changes whenever the mean of the signal shifts. fig , ax_array = rpt . display ( signal , bkps ) We can now perform change point detection, meaning finding the indexe where the signal mean changes. To that end, we use a well-known method called Pelt with a \\(L_2\\) cost function. (More information on these terms in the section What is change point detection? and the User guide .) # detection algo = rpt . Pelt ( model = \"l2\" ) . fit ( signal ) result = algo . predict ( pen = 200 ) # 'pen' is for 'penalty' print ( result ) [200, 390, 590, 795, 1000] Again the first elements are change point indexes and the last is the number of samples. To visualy compare the true segmentation ( bkps ) and the estimated ones ( result ), we can resort to rpt.display a second time. In the following image, the alternating colors indicate the true breakpoints and the dashed vertical lines, the estimated breakpoints. # display rpt . display ( signal , bkps , result ) plt . show () In this simple example, both are quite similar and almost undistinguishable.","title":"Simple example"},{"location":"notebooks/simple-example/#basic-usage","text":"Let's start with a simple example to illustrate the use of ruptures. First, we make the necessary imports and generate a piecewise constant signal with noise. import matplotlib.pyplot as plt # for display purposes import ruptures as rpt # our package # generate signal n_samples , dim , sigma = 1000 , 3 , 2 n_bkps = 4 # number of breakpoints signal , bkps = rpt . pw_constant ( n_samples , dim , n_bkps , noise_std = sigma ) The true change points of this synthetic signal are available in the bkps variable. print ( bkps ) [199, 390, 592, 797, 1000] Note that the first four element are change point indexes while the last is simply the number of samples. (This is a technical convention so that functions in ruptures always know the length of the signal at hand.) It is also possible to plot our \\(\\mathbb{R}^3\\) -valued signal along with the true change points with the rpt.display function. In the following image, the color changes whenever the mean of the signal shifts. fig , ax_array = rpt . display ( signal , bkps ) We can now perform change point detection, meaning finding the indexe where the signal mean changes. To that end, we use a well-known method called Pelt with a \\(L_2\\) cost function. (More information on these terms in the section What is change point detection? and the User guide .) # detection algo = rpt . Pelt ( model = \"l2\" ) . fit ( signal ) result = algo . predict ( pen = 200 ) # 'pen' is for 'penalty' print ( result ) [200, 390, 590, 795, 1000] Again the first elements are change point indexes and the last is the number of samples. To visualy compare the true segmentation ( bkps ) and the estimated ones ( result ), we can resort to rpt.display a second time. In the following image, the alternating colors indicate the true breakpoints and the dashed vertical lines, the estimated breakpoints. # display rpt . display ( signal , bkps , result ) plt . show () In this simple example, both are quite similar and almost undistinguishable.","title":"Basic usage"}]}